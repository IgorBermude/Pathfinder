<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/pathfinder/ui/profile/ProfileFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/pathfinder/ui/profile/ProfileFragment.kt" />
              <option name="originalContent" value="package com.example.pathfinder.ui.profile&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.graphics.Rect&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.view.ViewTreeObserver&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.ImageView&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.activityViewModels&#10;import androidx.fragment.app.viewModels&#10;import androidx.lifecycle.lifecycleScope&#10;import com.bumptech.glide.Glide&#10;import com.example.pathfinder.R&#10;import com.example.pathfinder.data.AuthViewModel&#10;import com.example.pathfinder.data.models.Usuario&#10;import com.example.pathfinder.util.AndroidUtil&#10;import com.example.pathfinder.util.FirebaseUtil&#10;import com.example.pathfinder.util.NavigationViewUtils&#10;import com.example.pathfinder.util.FuncoesUteis&#10;import com.github.dhaval2404.imagepicker.ImagePicker&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import android.view.inputmethod.InputMethodManager&#10;&#10;&#10;class ProfileFragment : Fragment() {&#10;&#10;    companion object {&#10;        fun newInstance() = ProfileFragment()&#10;    }&#10;&#10;    private val viewModel: ProfileViewModel by viewModels()&#10;    private val auth: FirebaseAuth = FirebaseAuth.getInstance()&#10;    private val firestore: FirebaseFirestore = FirebaseFirestore.getInstance()&#10;    private lateinit var imagePickLauncher: ActivityResultLauncher&lt;Intent&gt;&#10;    private var selectedImageUri: Uri? = null&#10;    private val authViewModel: AuthViewModel by activityViewModels { AuthViewModel.Factory }&#10;    var editarUsuarioBtn: Button? = null&#10;    var progressBar: ProgressBar? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        val view = inflater.inflate(R.layout.fragment_profile, container, false)&#10;        setUserData(view)&#10;        NavigationViewUtils.esconderBottomNavigationView(requireActivity())&#10;        return view&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        // Utilizo a library de image picker para selecionar a foto do usuário&#10;        imagePickLauncher = registerForActivityResult(&#10;            androidx.activity.result.contract.ActivityResultContracts.StartActivityForResult()&#10;        ) { result -&gt;&#10;            if (result.resultCode == Activity.RESULT_OK) {&#10;                val data = result.data&#10;                if(data!= null &amp;&amp; data.data != null) {&#10;                    selectedImageUri = data.data&#10;                    AndroidUtil.setProfilePic(&#10;                        requireContext(),&#10;                        selectedImageUri,&#10;                        requireView().findViewById&lt;ImageView&gt;(R.id.imageView)&#10;                    )&#10;                }&#10;&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        editarUsuarioBtn = view.findViewById(R.id.btn_editar_profile)&#10;        progressBar = view.findViewById(R.id.profile_progress_bar)&#10;&#10;        val nomeUsuarioTxt = view.findViewById&lt;TextView&gt;(R.id.nomeUsuario)&#10;        val emailTxt = view.findViewById&lt;TextView&gt;(R.id.email)&#10;        val senhaTxt = view.findViewById&lt;TextView&gt;(R.id.senha)&#10;        val idadeTxt = view.findViewById&lt;TextView&gt;(R.id.idade)&#10;        val enderecoTxt = view.findViewById&lt;TextView&gt;(R.id.endereco)&#10;&#10;        val editarSenhaTxt = view.findViewById&lt;TextView&gt;(R.id.editarSenha)&#10;        val editarEmailTxt = view.findViewById&lt;TextView&gt;(R.id.editarEmail)&#10;        val editarIdadeTxt = view.findViewById&lt;TextView&gt;(R.id.editarIdade)&#10;        val editarNomeUsuarioTxt = view.findViewById&lt;TextView&gt;(R.id.editarNomeUsuario)&#10;        val editarEnderecoTxt = view.findViewById&lt;TextView&gt;(R.id.editarEndereco)&#10;&#10;        editarSenhaTxt.setOnClickListener {&#10;            editarSenhaTxt.visibility = View.INVISIBLE&#10;            val parent = senhaTxt.parent as ViewGroup&#10;            val editText = FuncoesUteis.trocarTextViewPorEditText(parent, senhaTxt)&#10;            editarCampoTexto(editText, parent, senhaTxt, editarSenhaTxt)&#10;        }&#10;        editarEmailTxt.setOnClickListener {&#10;            editarEmailTxt.visibility = View.INVISIBLE&#10;            val parent = emailTxt.parent as ViewGroup&#10;            val editText = FuncoesUteis.trocarTextViewPorEditText(parent, emailTxt)&#10;            editarCampoTexto(editText, parent, emailTxt, editarEmailTxt)&#10;        }&#10;        editarIdadeTxt.setOnClickListener {&#10;            editarIdadeTxt.visibility = View.INVISIBLE&#10;            val parent = idadeTxt.parent as ViewGroup&#10;            val editText = FuncoesUteis.trocarTextViewPorEditText(parent, idadeTxt)&#10;            editarCampoTexto(editText, parent, idadeTxt, editarIdadeTxt)&#10;        }&#10;        editarNomeUsuarioTxt.setOnClickListener {&#10;            editarNomeUsuarioTxt.visibility = View.INVISIBLE&#10;            val parent = nomeUsuarioTxt.parent as ViewGroup&#10;            val editText = FuncoesUteis.trocarTextViewPorEditText(parent, nomeUsuarioTxt)&#10;            editarCampoTexto(editText, parent, nomeUsuarioTxt, editarNomeUsuarioTxt)&#10;        }&#10;        editarEnderecoTxt.setOnClickListener {&#10;            editarEnderecoTxt.visibility = View.INVISIBLE&#10;            val parent = enderecoTxt.parent as ViewGroup&#10;            val editText = FuncoesUteis.trocarTextViewPorEditText(parent, enderecoTxt)&#10;            editarCampoTexto(editText, parent, enderecoTxt, editarEnderecoTxt)&#10;        }&#10;&#10;        // Botão de voltar com animação&#10;        view.findViewById&lt;ImageButton&gt;(R.id.btn_voltar).setOnClickListener { btn -&gt;&#10;            btn.animate()&#10;                .scaleX(0.85f)&#10;                .scaleY(0.85f)&#10;                .setDuration(100)&#10;                .withEndAction {&#10;                    btn.animate()&#10;                        .scaleX(1f)&#10;                        .scaleY(1f)&#10;                        .setDuration(100)&#10;                        .withEndAction {&#10;                            requireActivity().onBackPressedDispatcher.onBackPressed()&#10;                        }&#10;                        .start()&#10;                }&#10;                .start()&#10;        }&#10;&#10;        view.findViewById&lt;ImageView&gt;(R.id.imageView).setOnClickListener {&#10;            ImagePicker.with(this).cropSquare().compress(512).maxResultSize(512,512)&#10;                .createIntent { intent -&gt;&#10;                    imagePickLauncher.launch(intent)&#10;                }&#10;        }&#10;&#10;        view.findViewById&lt;TextView&gt;(R.id.btn_editar_profile).setOnClickListener {&#10;            setInProgress(true)&#10;            val imageBase64 = selectedImageUri?.let {&#10;                FirebaseUtil.uriToBase64(requireContext(), it)&#10;            }&#10;&#10;            // Pega os dados atuais dos campos&#10;            val nome = view.findViewById&lt;TextView&gt;(R.id.nomeUsuario).text.toString()&#10;            val email = view.findViewById&lt;TextView&gt;(R.id.email).text.toString()&#10;            val senha = view.findViewById&lt;TextView&gt;(R.id.senha).text.toString()&#10;            val idadeStr = view.findViewById&lt;TextView&gt;(R.id.idade).text.toString()&#10;&#10;            // Converta idade para Timestamp se necessário (aqui mantido como String)&#10;            val usuario = Usuario(&#10;                idUsuario = auth.currentUser?.uid,&#10;                nomeUsuario = nome,&#10;                emailUsuario = email,&#10;                senhaUsuario = senha,&#10;                idadeUsuario = FuncoesUteis.parseDate(idadeStr), // ajuste se necessário&#10;                fotoUsuario = imageBase64&#10;            )&#10;&#10;            authViewModel.alterar(usuario)&#10;&#10;            // Observa o resultado e mostra Toast&#10;            lifecycleScope.launch {&#10;                authViewModel.authUiState.collectLatest { state -&gt;&#10;                    when (state) {&#10;                        com.example.pathfinder.LoginUiState.SUCCESS -&gt; {&#10;                            Toast.makeText(requireContext(), &quot;Perfil atualizado com sucesso!&quot;, Toast.LENGTH_SHORT).show()&#10;                            setInProgress(false)&#10;                            setUserData(requireView())&#10;                        }&#10;                        com.example.pathfinder.LoginUiState.ERROR -&gt; {&#10;                            Toast.makeText(requireContext(), &quot;Erro ao atualizar perfil.&quot;, Toast.LENGTH_SHORT).show()&#10;                            setInProgress(false)&#10;                        }&#10;                        else -&gt; {}&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        view.findViewById&lt;TextView&gt;(R.id.textView2).setOnClickListener {&#10;            // Implementar ação para editar nome de usuário&#10;        }&#10;    }&#10;&#10;    private fun editarCampoTexto(editText: EditText, parent: ViewGroup, textView: TextView, clickedText: TextView) {&#10;        editText.isFocusableInTouchMode = true&#10;        editText.isFocusable = true&#10;        editText.requestFocus()&#10;        editText.setSelection(editText.text.length)&#10;        val imm = requireContext().getSystemService(android.content.Context.INPUT_METHOD_SERVICE) as android.view.inputmethod.InputMethodManager&#10;        imm.showSoftInput(editText, android.view.inputmethod.InputMethodManager.SHOW_IMPLICIT)&#10;&#10;        // Quando o usuário pressionar Enter ou sair do campo, transforma de volta em TextView&#10;        editText.setOnEditorActionListener { v, actionId, event -&gt;&#10;            // Funciona corretamente&#10;            FuncoesUteis.trocarEditTextPorTextView(parent, editText, textView)&#10;            true&#10;        }&#10;        editText.setOnFocusChangeListener { v, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                v.postDelayed({&#10;                    // Verifica se o editText ainda está no parent antes de tentar trocar&#10;                    if (parent.indexOfChild(editText) != -1) {&#10;                        FuncoesUteis.trocarEditTextPorTextView(parent, editText, textView)&#10;                    }&#10;                }, 100)&#10;            }&#10;            clickedText.visibility = View.VISIBLE&#10;        }&#10;        // Removido o uso de clearFocusOnKeyboardClose para evitar NPE&#10;        editText.clearFocusOnKeyboardClose(requireActivity())&#10;    }&#10;&#10;    private fun setUserData(view: View) {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser != null) {&#10;            val userId = currentUser.uid&#10;            firestore.collection(&quot;usuarios&quot;).document(userId).get()&#10;                .addOnSuccessListener { document -&gt;&#10;                    if (document != null) {&#10;                        val usuario = document.toObject(Usuario::class.java)&#10;                        if (usuario != null) {&#10;                            view.findViewById&lt;TextView&gt;(R.id.textView2).text = usuario.nomeUsuario&#10;                            view.findViewById&lt;TextView&gt;(R.id.textView3).text = usuario.emailUsuario&#10;                            view.findViewById&lt;TextView&gt;(R.id.senha).text = usuario.senhaUsuario // Ocultar senha&#10;                            view.findViewById&lt;TextView&gt;(R.id.email).text = usuario.emailUsuario&#10;                            view.findViewById&lt;TextView&gt;(R.id.idade).text = formatDate(usuario.idadeUsuario)&#10;                            view.findViewById&lt;TextView&gt;(R.id.nomeUsuario).text = usuario.nomeUsuario&#10;                            view.findViewById&lt;TextView&gt;(R.id.endereco).text = usuario.enderecoUsuario?.toString() ?: &quot;Não informado&quot;&#10;                            val imageView = view.findViewById&lt;ImageView&gt;(R.id.imageView)&#10;                            if (!usuario.fotoUsuario.isNullOrEmpty()) {&#10;                                val bitmap = FirebaseUtil.base64ToBitmap(usuario.fotoUsuario!!)&#10;                                Glide.with(view.context)&#10;                                    .load(bitmap)&#10;                                    .circleCrop()&#10;                                    .override(512, 512) // Ajuste o tamanho do círculo aqui (exemplo: 128x128 px)&#10;                                    .into(imageView)&#10;                            } else {&#10;                                imageView.setImageResource(R.drawable.ic_profile)&#10;                                &#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                .addOnFailureListener { exception -&gt;&#10;                    Toast.makeText(requireContext(), &quot;Erro ao carregar dados do usuário ${exception.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun formatDate(date: Timestamp?): String {&#10;        return if (date != null) {&#10;            val formatter = SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault())&#10;            val dateObj = date.toDate() // Corrigido: converte Timestamp para Date&#10;            formatter.format(dateObj)&#10;        } else {&#10;            &quot;Não informado&quot;&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        NavigationViewUtils.mostrarBottomNavigationView(requireActivity())&#10;    }&#10;&#10;    fun setInProgress(inProgress: Boolean) {&#10;        if (inProgress) {&#10;            progressBar?.visibility = View.VISIBLE&#10;            editarUsuarioBtn?.visibility = View.GONE&#10;        } else {&#10;            progressBar?.visibility = View.GONE&#10;            editarUsuarioBtn?.visibility = View.VISIBLE&#10;        }&#10;    }&#10;&#10;    fun EditText.clearFocusOnKeyboardClose(activity: Activity) {&#10;        val rootView = activity.window.decorView&#10;&#10;        rootView.viewTreeObserver.addOnGlobalLayoutListener(object :&#10;            ViewTreeObserver.OnGlobalLayoutListener {&#10;            private var isKeyboardVisible = false&#10;&#10;            override fun onGlobalLayout() {&#10;                val rect = Rect()&#10;                rootView.getWindowVisibleDisplayFrame(rect)&#10;                val screenHeight = rootView.height&#10;                val keypadHeight = screenHeight - rect.bottom&#10;&#10;                val keyboardNowVisible = keypadHeight &gt; screenHeight * 0.15&#10;&#10;                if (isKeyboardVisible &amp;&amp; !keyboardNowVisible) {&#10;                    // Teclado foi fechado&#10;                    this@clearFocusOnKeyboardClose.clearFocus()&#10;                    hideKeyboard(activity, this@clearFocusOnKeyboardClose)&#10;                }&#10;&#10;                isKeyboardVisible = keyboardNowVisible&#10;            }&#10;        })&#10;    }&#10;&#10;    private fun hideKeyboard(activity: Activity, view: View) {&#10;        val imm = activity.getSystemService(Activity.INPUT_METHOD_SERVICE) as InputMethodManager&#10;        imm.hideSoftInputFromWindow(view.windowToken, 0)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.pathfinder.ui.profile&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.graphics.Rect&#10;import android.net.Uri&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.view.ViewTreeObserver&#10;import android.widget.Button&#10;import android.widget.EditText&#10;import android.widget.ImageButton&#10;import android.widget.ImageView&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.result.ActivityResultLauncher&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.activityViewModels&#10;import androidx.fragment.app.viewModels&#10;import androidx.lifecycle.lifecycleScope&#10;import com.bumptech.glide.Glide&#10;import com.example.pathfinder.R&#10;import com.example.pathfinder.data.AuthViewModel&#10;import com.example.pathfinder.data.models.Usuario&#10;import com.example.pathfinder.util.AndroidUtil&#10;import com.example.pathfinder.util.FirebaseUtil&#10;import com.example.pathfinder.util.NavigationViewUtils&#10;import com.example.pathfinder.util.FuncoesUteis&#10;import com.github.dhaval2404.imagepicker.ImagePicker&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import java.text.SimpleDateFormat&#10;import java.util.Locale&#10;import android.view.inputmethod.InputMethodManager&#10;&#10;&#10;class ProfileFragment : Fragment() {&#10;&#10;    companion object {&#10;        fun newInstance() = ProfileFragment()&#10;    }&#10;&#10;    private val viewModel: ProfileViewModel by viewModels()&#10;    private val auth: FirebaseAuth = FirebaseAuth.getInstance()&#10;    private val firestore: FirebaseFirestore = FirebaseFirestore.getInstance()&#10;    private lateinit var imagePickLauncher: ActivityResultLauncher&lt;Intent&gt;&#10;    private var selectedImageUri: Uri? = null&#10;    private val authViewModel: AuthViewModel by activityViewModels { AuthViewModel.Factory }&#10;    var editarUsuarioBtn: Button? = null&#10;    var progressBar: ProgressBar? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        val view = inflater.inflate(R.layout.fragment_profile, container, false)&#10;        setUserData(view)&#10;        NavigationViewUtils.esconderBottomNavigationView(requireActivity())&#10;        return view&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        // Utilizo a library de image picker para selecionar a foto do usuário&#10;        imagePickLauncher = registerForActivityResult(&#10;            androidx.activity.result.contract.ActivityResultContracts.StartActivityForResult()&#10;        ) { result -&gt;&#10;            if (result.resultCode == Activity.RESULT_OK) {&#10;                val data = result.data&#10;                if(data!= null &amp;&amp; data.data != null) {&#10;                    selectedImageUri = data.data&#10;                    AndroidUtil.setProfilePic(&#10;                        requireContext(),&#10;                        selectedImageUri,&#10;                        requireView().findViewById&lt;ImageView&gt;(R.id.imageView)&#10;                    )&#10;                }&#10;&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;        editarUsuarioBtn = view.findViewById(R.id.btn_editar_profile)&#10;        progressBar = view.findViewById(R.id.profile_progress_bar)&#10;&#10;        val nomeUsuarioTxt = view.findViewById&lt;TextView&gt;(R.id.nomeUsuario)&#10;        val emailTxt = view.findViewById&lt;TextView&gt;(R.id.email)&#10;        val senhaTxt = view.findViewById&lt;TextView&gt;(R.id.senha)&#10;        val idadeTxt = view.findViewById&lt;TextView&gt;(R.id.idade)&#10;        val enderecoTxt = view.findViewById&lt;TextView&gt;(R.id.endereco)&#10;&#10;        val editarSenhaTxt = view.findViewById&lt;TextView&gt;(R.id.editarSenha)&#10;        val editarEmailTxt = view.findViewById&lt;TextView&gt;(R.id.editarEmail)&#10;        val editarIdadeTxt = view.findViewById&lt;TextView&gt;(R.id.editarIdade)&#10;        val editarNomeUsuarioTxt = view.findViewById&lt;TextView&gt;(R.id.editarNomeUsuario)&#10;        val editarEnderecoTxt = view.findViewById&lt;TextView&gt;(R.id.editarEndereco)&#10;&#10;        editarSenhaTxt.setOnClickListener {&#10;            editarSenhaTxt.visibility = View.INVISIBLE&#10;            val parent = senhaTxt.parent as ViewGroup&#10;            val editText = FuncoesUteis.trocarTextViewPorEditText(parent, senhaTxt)&#10;            editarCampoTexto(editText, parent, senhaTxt, editarSenhaTxt)&#10;        }&#10;        editarEmailTxt.setOnClickListener {&#10;            editarEmailTxt.visibility = View.INVISIBLE&#10;            val parent = emailTxt.parent as ViewGroup&#10;            val editText = FuncoesUteis.trocarTextViewPorEditText(parent, emailTxt)&#10;            editarCampoTexto(editText, parent, emailTxt, editarEmailTxt)&#10;        }&#10;        editarIdadeTxt.setOnClickListener {&#10;            editarIdadeTxt.visibility = View.INVISIBLE&#10;            val parent = idadeTxt.parent as ViewGroup&#10;            val editText = FuncoesUteis.trocarTextViewPorEditText(parent, idadeTxt)&#10;            editarCampoTexto(editText, parent, idadeTxt, editarIdadeTxt)&#10;        }&#10;        editarNomeUsuarioTxt.setOnClickListener {&#10;            editarNomeUsuarioTxt.visibility = View.INVISIBLE&#10;            val parent = nomeUsuarioTxt.parent as ViewGroup&#10;            val editText = FuncoesUteis.trocarTextViewPorEditText(parent, nomeUsuarioTxt)&#10;            editarCampoTexto(editText, parent, nomeUsuarioTxt, editarNomeUsuarioTxt)&#10;        }&#10;        editarEnderecoTxt.setOnClickListener {&#10;            editarEnderecoTxt.visibility = View.INVISIBLE&#10;            val parent = enderecoTxt.parent as ViewGroup&#10;            val editText = FuncoesUteis.trocarTextViewPorEditText(parent, enderecoTxt)&#10;            editarCampoTexto(editText, parent, enderecoTxt, editarEnderecoTxt)&#10;        }&#10;&#10;        // Botão de voltar com animação&#10;        view.findViewById&lt;ImageButton&gt;(R.id.btn_voltar).setOnClickListener { btn -&gt;&#10;            btn.animate()&#10;                .scaleX(0.85f)&#10;                .scaleY(0.85f)&#10;                .setDuration(100)&#10;                .withEndAction {&#10;                    btn.animate()&#10;                        .scaleX(1f)&#10;                        .scaleY(1f)&#10;                        .setDuration(100)&#10;                        .withEndAction {&#10;                            requireActivity().onBackPressedDispatcher.onBackPressed()&#10;                        }&#10;                        .start()&#10;                }&#10;                .start()&#10;        }&#10;&#10;        view.findViewById&lt;ImageView&gt;(R.id.imageView).setOnClickListener {&#10;            ImagePicker.with(this).cropSquare().compress(512).maxResultSize(512,512)&#10;                .createIntent { intent -&gt;&#10;                    imagePickLauncher.launch(intent)&#10;                }&#10;        }&#10;&#10;        view.findViewById&lt;TextView&gt;(R.id.btn_editar_profile).setOnClickListener {&#10;            setInProgress(true)&#10;            val imageBase64 = selectedImageUri?.let {&#10;                FirebaseUtil.uriToBase64(requireContext(), it)&#10;            }&#10;&#10;            // Pega os dados atuais dos campos&#10;            val nome = view.findViewById&lt;TextView&gt;(R.id.nomeUsuario).text.toString()&#10;            val email = view.findViewById&lt;TextView&gt;(R.id.email).text.toString()&#10;            val senha = view.findViewById&lt;TextView&gt;(R.id.senha).text.toString()&#10;            val idadeStr = view.findViewById&lt;TextView&gt;(R.id.idade).text.toString()&#10;&#10;            // Converta idade para Timestamp se necessário (aqui mantido como String)&#10;            val usuario = Usuario(&#10;                idUsuario = auth.currentUser?.uid,&#10;                nomeUsuario = nome,&#10;                emailUsuario = email,&#10;                senhaUsuario = senha,&#10;                idadeUsuario = FuncoesUteis.parseDate(idadeStr), // ajuste se necessário&#10;                fotoUsuario = imageBase64&#10;            )&#10;&#10;            authViewModel.alterar(usuario)&#10;&#10;            // Observa o resultado e mostra Toast&#10;            lifecycleScope.launch {&#10;                authViewModel.authUiState.collectLatest { state -&gt;&#10;                    when (state) {&#10;                        com.example.pathfinder.LoginUiState.SUCCESS -&gt; {&#10;                            Toast.makeText(requireContext(), &quot;Perfil atualizado com sucesso!&quot;, Toast.LENGTH_SHORT).show()&#10;                            setInProgress(false)&#10;                            setUserData(requireView())&#10;                        }&#10;                        com.example.pathfinder.LoginUiState.ERROR -&gt; {&#10;                            Toast.makeText(requireContext(), &quot;Erro ao atualizar perfil.&quot;, Toast.LENGTH_SHORT).show()&#10;                            setInProgress(false)&#10;                        }&#10;                        else -&gt; {}&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        view.findViewById&lt;TextView&gt;(R.id.textView2).setOnClickListener {&#10;            // Implementar ação para editar nome de usuário&#10;        }&#10;    }&#10;&#10;    private fun editarCampoTexto(editText: EditText, parent: ViewGroup, textView: TextView, clickedText: TextView) {&#10;        editText.isFocusableInTouchMode = true&#10;        editText.isFocusable = true&#10;        editText.requestFocus()&#10;        editText.setSelection(editText.text.length)&#10;        val imm = requireContext().getSystemService(android.content.Context.INPUT_METHOD_SERVICE) as android.view.inputmethod.InputMethodManager&#10;        imm.showSoftInput(editText, android.view.inputmethod.InputMethodManager.SHOW_IMPLICIT)&#10;&#10;        // Quando o usuário pressionar Enter ou sair do campo, transforma de volta em TextView&#10;        editText.setOnEditorActionListener { v, actionId, event -&gt;&#10;            // Funciona corretamente&#10;            FuncoesUteis.trocarEditTextPorTextView(parent, editText, textView)&#10;            true&#10;        }&#10;        editText.setOnFocusChangeListener { v, hasFocus -&gt;&#10;            if (!hasFocus) {&#10;                v.postDelayed({&#10;                    // Verifica se o editText ainda está no parent antes de tentar trocar&#10;                    if (parent.indexOfChild(editText) != -1) {&#10;                        FuncoesUteis.trocarEditTextPorTextView(parent, editText, textView)&#10;                    }&#10;                }, 100)&#10;            }&#10;            clickedText.visibility = View.VISIBLE&#10;        }&#10;        // Removido o uso de clearFocusOnKeyboardClose para evitar NPE&#10;        editText.clearFocusOnKeyboardClose(requireActivity())&#10;    }&#10;&#10;    private fun setUserData(view: View) {&#10;        val currentUser = auth.currentUser&#10;        if (currentUser != null) {&#10;            val userId = currentUser.uid&#10;            firestore.collection(&quot;usuarios&quot;).document(userId).get()&#10;                .addOnSuccessListener { document -&gt;&#10;                    if (document != null) {&#10;                        val usuario = document.toObject(Usuario::class.java)&#10;                        if (usuario != null) {&#10;                            view.findViewById&lt;TextView&gt;(R.id.textView2).text = usuario.nomeUsuario&#10;                            view.findViewById&lt;TextView&gt;(R.id.textView3).text = usuario.emailUsuario&#10;                            view.findViewById&lt;TextView&gt;(R.id.senha).text = usuario.senhaUsuario // Ocultar senha&#10;                            view.findViewById&lt;TextView&gt;(R.id.email).text = usuario.emailUsuario&#10;                            view.findViewById&lt;TextView&gt;(R.id.idade).text = formatDate(usuario.idadeUsuario)&#10;                            view.findViewById&lt;TextView&gt;(R.id.nomeUsuario).text = usuario.nomeUsuario&#10;                            view.findViewById&lt;TextView&gt;(R.id.endereco).text = usuario.enderecoUsuario?.toString() ?: &quot;Não informado&quot;&#10;                            val imageView = view.findViewById&lt;ImageView&gt;(R.id.imageView)&#10;                            if (!usuario.fotoUsuario.isNullOrEmpty()) {&#10;                                val bitmap = FirebaseUtil.base64ToBitmap(usuario.fotoUsuario!!)&#10;                                Glide.with(view.context)&#10;                                    .load(bitmap)&#10;                                    .circleCrop()&#10;                                    .override(512, 512) // Ajuste o tamanho do círculo aqui (exemplo: 128x128 px)&#10;                                    .into(imageView)&#10;                            } else {&#10;                                imageView.setImageResource(R.drawable.ic_profile)&#10;                                &#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                .addOnFailureListener { exception -&gt;&#10;                    Toast.makeText(requireContext(), &quot;Erro ao carregar dados do usuário ${exception.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun formatDate(date: Timestamp?): String {&#10;        return if (date != null) {&#10;            val formatter = SimpleDateFormat(&quot;dd/MM/yyyy&quot;, Locale.getDefault())&#10;            val dateObj = date.toDate() // Corrigido: converte Timestamp para Date&#10;            formatter.format(dateObj)&#10;        } else {&#10;            &quot;Não informado&quot;&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        NavigationViewUtils.mostrarBottomNavigationView(requireActivity())&#10;    }&#10;&#10;    fun setInProgress(inProgress: Boolean) {&#10;        if (inProgress) {&#10;            progressBar?.visibility = View.VISIBLE&#10;            editarUsuarioBtn?.visibility = View.GONE&#10;        } else {&#10;            progressBar?.visibility = View.GONE&#10;            editarUsuarioBtn?.visibility = View.VISIBLE&#10;        }&#10;    }&#10;&#10;    fun EditText.clearFocusOnKeyboardClose(activity: Activity) {&#10;        val rootView = activity.window.decorView&#10;&#10;        rootView.viewTreeObserver.addOnGlobalLayoutListener(object :&#10;            ViewTreeObserver.OnGlobalLayoutListener {&#10;            private var isKeyboardVisible = false&#10;&#10;            override fun onGlobalLayout() {&#10;                val rect = Rect()&#10;                rootView.getWindowVisibleDisplayFrame(rect)&#10;                val screenHeight = rootView.height&#10;                val keypadHeight = screenHeight - rect.bottom&#10;&#10;                val keyboardNowVisible = keypadHeight &gt; screenHeight * 0.15&#10;&#10;                if (isKeyboardVisible &amp;&amp; !keyboardNowVisible) {&#10;                    // Teclado foi fechado&#10;                    this@clearFocusOnKeyboardClose.clearFocus()&#10;                    hideKeyboard(activity, this@clearFocusOnKeyboardClose)&#10;                }&#10;&#10;                isKeyboardVisible = keyboardNowVisible&#10;            }&#10;        })&#10;    }&#10;&#10;    private fun hideKeyboard(activity: Activity, view: View) {&#10;        val imm = activity.getSystemService(Activity.INPUT_METHOD_SERVICE) as InputMethodManager&#10;        imm.hideSoftInputFromWindow(view.windowToken, 0)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>