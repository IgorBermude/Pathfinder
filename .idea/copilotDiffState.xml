<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/pathfinder/ui/components/DestinoAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/pathfinder/ui/components/DestinoAdapter.kt" />
              <option name="originalContent" value="package com.example.pathfinder.ui.components&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.pathfinder.R&#10;import com.example.pathfinder.data.models.Destino&#10;&#10;class DestinoAdapter(&#10;    var destinos: List&lt;Destino&gt;,&#10;    private val onDeleteClick: (Destino) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;DestinoAdapter.DestinoViewHolder&gt;() {&#10;&#10;    class DestinoViewHolder(view: View) : RecyclerView.ViewHolder(view) {&#10;        val nome: TextView = view.findViewById(R.id.text_nome)&#10;        val distancia: TextView = view.findViewById(R.id.text_distancia)&#10;        val delete: ImageView = view.findViewById(R.id.icon_delete)&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): DestinoViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_destino, parent, false)&#10;        return DestinoViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: DestinoViewHolder, position: Int) {&#10;        val destino = destinos[position]&#10;        holder.nome.text = destino.nomeDestino&#10;        holder.distancia.text = destino.distancia&#10;            ?.div(1000.0)&#10;            ?.let { &quot;Distância: %.1f km&quot;.format(it) }&#10;            ?: &quot;Distância: Desconhecida&quot;&#10;        holder.delete.setOnClickListener { onDeleteClick(destino) }&#10;    }&#10;&#10;    fun update(novos: List&lt;Destino&gt;) {&#10;        this.destinos = novos&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    override fun getItemCount(): Int = destinos.size&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.pathfinder.ui.components&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.pathfinder.R&#10;import com.example.pathfinder.data.models.Destino&#10;&#10;class DestinoAdapter(&#10;    var destinos: List&lt;Destino&gt;,&#10;    private val onDeleteClick: (Destino) -&gt; Unit,&#10;    private val onDestinosVazio: (() -&gt; Unit)? = null // Novo callback opcional&#10;) : RecyclerView.Adapter&lt;DestinoAdapter.DestinoViewHolder&gt;() {&#10;&#10;    class DestinoViewHolder(view: View) : RecyclerView.ViewHolder(view) {&#10;        val nome: TextView = view.findViewById(R.id.text_nome)&#10;        val distancia: TextView = view.findViewById(R.id.text_distancia)&#10;        val delete: ImageView = view.findViewById(R.id.icon_delete)&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): DestinoViewHolder {&#10;        val view = LayoutInflater.from(parent.context)&#10;            .inflate(R.layout.item_destino, parent, false)&#10;        return DestinoViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: DestinoViewHolder, position: Int) {&#10;        val destino = destinos[position]&#10;        holder.nome.text = destino.nomeDestino&#10;        holder.distancia.text = destino.distancia&#10;            ?.div(1000.0)&#10;            ?.let { &quot;Distância: %.1f km&quot;.format(it) }&#10;            ?: &quot;Distância: Desconhecida&quot;&#10;        holder.delete.setOnClickListener { &#10;            onDeleteClick(destino)&#10;            // Após exclusão, verifica se a lista está vazia&#10;            if (destinos.size == 1) { // Após remover, ficará vazio&#10;                onDestinosVazio?.invoke()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun update(novos: List&lt;Destino&gt;) {&#10;        this.destinos = novos&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    override fun getItemCount(): Int = destinos.size&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/pathfinder/ui/components/MapaFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/pathfinder/ui/components/MapaFragment.kt" />
              <option name="originalContent" value="package com.example.pathfinder.ui.components&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.content.res.Resources&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.Toast&#10;import androidx.annotation.RequiresPermission&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.activityViewModels&#10;import com.example.pathfinder.R&#10;import com.example.pathfinder.data.models.Destino&#10;import com.example.pathfinder.ui.home.HomeViewModel&#10;import com.example.pathfinder.ui.searchAc.SearchViewModel&#10;import com.mapbox.api.directions.v5.models.DirectionsRoute&#10;import com.mapbox.api.directions.v5.models.RouteOptions&#10;import com.mapbox.geojson.LineString&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.maps.CameraOptions&#10;import com.mapbox.maps.CameraState&#10;import com.mapbox.maps.MapView&#10;import com.mapbox.maps.Style&#10;import com.mapbox.maps.plugin.animation.flyTo&#10;import com.mapbox.maps.plugin.annotation.annotations&#10;import com.mapbox.maps.plugin.annotation.generated.PointAnnotationOptions&#10;import com.mapbox.maps.plugin.annotation.generated.createPointAnnotationManager&#10;import com.mapbox.maps.plugin.compass.compass&#10;import com.mapbox.maps.plugin.gestures.gestures&#10;import com.mapbox.maps.plugin.locationcomponent.OnIndicatorPositionChangedListener&#10;import com.mapbox.maps.plugin.locationcomponent.location&#10;import com.mapbox.maps.plugin.scalebar.scalebar&#10;import com.mapbox.navigation.base.extensions.applyDefaultNavigationOptions&#10;import com.mapbox.navigation.base.extensions.applyLanguageAndVoiceUnitOptions&#10;import com.mapbox.navigation.core.MapboxNavigation&#10;import com.mapbox.navigation.core.lifecycle.requireMapboxNavigation&#10;import com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver&#10;import com.mapbox.navigation.base.route.NavigationRoute&#10;import com.mapbox.navigation.base.route.NavigationRouterCallback&#10;import com.mapbox.navigation.base.route.RouterFailure&#10;import com.mapbox.navigation.core.directions.session.RoutesObserver&#10;import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineApi&#10;import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineView&#10;import com.mapbox.navigation.ui.maps.route.line.model.NavigationRouteLine&#10;import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineViewOptions&#10;import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineApiOptions&#10;import com.mapbox.navigation.ui.maps.route.line.model.RouteLineColorResources&#10;import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider&#10;import com.mapbox.common.location.toAndroidLocation&#10;import com.mapbox.navigation.core.trip.session.LocationObserver&#10;import com.mapbox.navigation.core.trip.session.LocationMatcherResult&#10;import com.mapbox.common.location.Location&#10;import com.mapbox.maps.EdgeInsets&#10;import com.mapbox.maps.ImageHolder&#10;import com.mapbox.maps.MapboxDelicateApi&#10;import com.mapbox.maps.plugin.LocationPuck2D&#10;import com.mapbox.maps.plugin.animation.MapAnimationOptions&#10;import com.mapbox.maps.plugin.animation.camera&#10;import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI&#10;import com.mapbox.navigation.base.formatter.DistanceFormatterOptions&#10;import com.mapbox.navigation.base.options.NavigationOptions&#10;import com.mapbox.navigation.core.lifecycle.MapboxNavigationApp&#10;import com.mapbox.navigation.core.replay.route.ReplayProgressObserver&#10;import com.mapbox.navigation.core.replay.route.ReplayRouteMapper&#10;import com.mapbox.navigation.core.trip.session.OffRouteObserver&#10;import com.mapbox.navigation.core.trip.session.RouteProgressObserver&#10;import com.mapbox.navigation.core.trip.session.VoiceInstructionsObserver&#10;import com.mapbox.navigation.tripdata.speedlimit.api.MapboxSpeedInfoApi&#10;import com.mapbox.navigation.tripdata.speedlimit.model.SpeedInfoValue&#10;import com.mapbox.navigation.ui.maps.camera.NavigationCamera&#10;import com.mapbox.navigation.ui.maps.camera.data.MapboxNavigationViewportDataSource&#10;import com.mapbox.navigation.ui.maps.camera.lifecycle.NavigationBasicGesturesHandler&#10;import com.mapbox.navigation.ui.maps.camera.state.NavigationCameraState&#10;import com.mapbox.navigation.ui.maps.camera.transition.NavigationCameraTransitionOptions&#10;import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowApi&#10;import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowView&#10;import com.mapbox.navigation.ui.maps.route.arrow.model.RouteArrowOptions&#10;import java.util.Date&#10;import com.mapbox.maps.plugin.gestures.OnMapClickListener&#10;import com.mapbox.maps.plugin.gestures.addOnMapClickListener&#10;import com.mapbox.maps.plugin.gestures.removeOnMapClickListener&#10;import com.mapbox.search.ApiType&#10;import com.mapbox.search.ResponseInfo&#10;import com.mapbox.search.ReverseGeoOptions&#10;import com.mapbox.search.SearchCallback&#10;import com.mapbox.search.SearchEngine&#10;import com.mapbox.search.SearchEngineSettings&#10;import com.mapbox.search.result.SearchResult&#10;&#10;class MapaFragment : Fragment() {&#10;&#10;    lateinit var mapView: MapView&#10;    private val mapManager = MapManeger // Use o MapManager para gerenciar a instância do mapa&#10;    private var instance: MapaFragment? = null&#10;    private lateinit var mapMarkersManager: MapMarkersManager&#10;    private val permissionRequestCode = 1001&#10;    private val SEARCH_REQUEST_CODE = 1001&#10;    private val preferences by lazy {&#10;        requireContext().getSharedPreferences(&quot;map_state&quot;, Context.MODE_PRIVATE)&#10;    }&#10;    // Navigation UI helpers&#10;    val navigationLocationProvider = NavigationLocationProvider()&#10;    private lateinit var routeLineApi: MapboxRouteLineApi&#10;    private lateinit var routeLineView: MapboxRouteLineView&#10;&#10;    var limitInfo: SpeedInfoValue? = null&#10;&#10;    /**&#10;     * Gets notified with location updates.&#10;     *&#10;     * Exposes raw updates coming directly from the location services&#10;     * and the updates enhanced by the Navigation SDK (cleaned up and matched to the road).&#10;     */&#10;    private val locationObserver = object : LocationObserver {&#10;        var firstLocationUpdateReceived = false&#10;&#10;        override fun onNewRawLocation(rawLocation: Location) {&#10;            // not handled&#10;        }&#10;&#10;        override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {&#10;            val enhancedLocation = locationMatcherResult.enhancedLocation&#10;            // update location puck's position on the map&#10;            navigationLocationProvider.changePosition(&#10;                location = enhancedLocation,&#10;                keyPoints = locationMatcherResult.keyPoints,&#10;            )&#10;&#10;            // update camera position to account for new location&#10;            viewportDataSource.onLocationChanged(enhancedLocation)&#10;            viewportDataSource.evaluate()&#10;&#10;            // if this is the first location update the activity has received,&#10;            // it's best to immediately move the camera to the current user location&#10;            if (!firstLocationUpdateReceived) {&#10;                firstLocationUpdateReceived = true&#10;                cameraSeguir()&#10;            }&#10;&#10;            limitInfo = speedInfoApi.updatePostedAndCurrentSpeed(&#10;                locationMatcherResult,&#10;                distanceFormatterOptions&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generates updates for the [routeArrowView] with the geometries and properties of maneuver arrows that should be drawn on the map.&#10;     */&#10;    val routeArrowApi: MapboxRouteArrowApi = MapboxRouteArrowApi()&#10;&#10;    /**&#10;     * Debug observer that makes sure the replayer has always an up-to-date information to generate mock updates.&#10;     */&#10;    private lateinit var replayProgressObserver: ReplayProgressObserver&#10;&#10;    /**&#10;     * Debug object that converts a route into events that can be replayed to navigate a route.&#10;     */&#10;    private val replayRouteMapper = ReplayRouteMapper()&#10;&#10;    // Delegate para o MapboxNavigation conforme recomendado&#10;    @OptIn(ExperimentalPreviewMapboxNavigationAPI::class)&#10;    val mapboxNavigation: MapboxNavigation by requireMapboxNavigation(&#10;        onResumedObserver = object : MapboxNavigationObserver {&#10;            @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;            override fun onAttached(mapboxNavigation: MapboxNavigation) {&#10;                mapboxNavigation.registerRoutesObserver(routesObserver)&#10;                mapboxNavigation.registerLocationObserver(locationObserver)&#10;                mapboxNavigation.startTripSession()&#10;                mapboxNavigation.registerOffRouteObserver(offRouteObserver)&#10;&#10;                replayProgressObserver = ReplayProgressObserver(mapboxNavigation.mapboxReplayer)&#10;                mapboxNavigation.registerRouteProgressObserver(replayProgressObserver)&#10;            }&#10;            override fun onDetached(mapboxNavigation: MapboxNavigation) {&#10;                mapboxNavigation.unregisterRoutesObserver(routesObserver)&#10;                mapboxNavigation.unregisterLocationObserver(locationObserver)&#10;                mapboxNavigation.unregisterRouteProgressObserver(replayProgressObserver)&#10;                mapboxNavigation.unregisterOffRouteObserver(offRouteObserver)&#10;            }&#10;        }&#10;    )&#10;&#10;    /**&#10;     * Draws maneuver arrows on the map based on the data [routeArrowApi].&#10;     */&#10;    lateinit var routeArrowView: MapboxRouteArrowView&#10;&#10;    val offRouteObserver = object : OffRouteObserver {&#10;        override fun onOffRouteStateChanged(offRoute: Boolean) {&#10;        }&#10;    }&#10;&#10;    private val routesObserver = RoutesObserver { routeUpdateResult -&gt;&#10;        if (routeUpdateResult.navigationRoutes.isNotEmpty()) {&#10;            // generate route geometries asynchronously and render them&#10;            routeLineApi.setNavigationRoutes(&#10;                routeUpdateResult.navigationRoutes&#10;            ) { value -&gt;&#10;                mapView.getMapboxMap().getStyle()?.apply {&#10;                    routeLineView.renderRouteDrawData(this, value)&#10;                }&#10;            }&#10;&#10;            // update the camera position to account for the new route&#10;            viewportDataSource.onRouteChanged(routeUpdateResult.navigationRoutes.first())&#10;            viewportDataSource.evaluate()&#10;        } else {&#10;            // remove the route line and route arrow from the map&#10;            val style = mapView.mapboxMap.style&#10;            if (style != null) {&#10;                routeLineApi.clearRouteLine { value -&gt;&#10;                    routeLineView.renderClearRouteLineValue(&#10;                        style,&#10;                        value&#10;                    )&#10;                }&#10;                routeArrowView.render(style, routeArrowApi.clearArrows())&#10;            }&#10;&#10;            // remove the route reference from camera position evaluations&#10;            viewportDataSource.clearRouteData()&#10;            viewportDataSource.evaluate()&#10;        }&#10;    }&#10;&#10;&#10;    lateinit var navigationCamera: NavigationCamera&#10;    lateinit var viewportDataSource: MapboxNavigationViewportDataSource&#10;    private val pixelDensity = Resources.getSystem().displayMetrics.density&#10;    private val overviewPadding: EdgeInsets by lazy {&#10;        EdgeInsets(&#10;            140.0 * pixelDensity,&#10;            40.0 * pixelDensity,&#10;            120.0 * pixelDensity,&#10;            40.0 * pixelDensity&#10;        )&#10;    }&#10;    private val followingPadding: EdgeInsets by lazy {&#10;        EdgeInsets(&#10;            180.0 * pixelDensity,&#10;            40.0 * pixelDensity,&#10;            150.0 * pixelDensity,&#10;            40.0 * pixelDensity&#10;        )&#10;    }&#10;&#10;    /**&#10;     * API used for formatting speed limit related data.&#10;     */&#10;    private val speedInfoApi: MapboxSpeedInfoApi by lazy {&#10;        MapboxSpeedInfoApi()&#10;    }&#10;&#10;    /**&#10;     * Options used for formatting speed information, such as mph or km/h.&#10;     * By default, the unit type will be determined based on the device's locale.&#10;     */&#10;    private val distanceFormatterOptions: DistanceFormatterOptions by lazy {&#10;        DistanceFormatterOptions.Builder(requireContext()).build()&#10;    }&#10;&#10;&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;&#10;        mapView = MapView(requireContext())&#10;        mapManager.initialize(mapView) // Inicialize o MapManager com o MapView&#10;&#10;        // Inicialize o mapMarkersManager após o mapView estar disponível&#10;        mapMarkersManager = MapMarkersManager(requireContext(), mapView)&#10;&#10;        // Inicialize RouteLineApi e RouteLineView&#10;        val routeLineViewOptions = MapboxRouteLineViewOptions.Builder(requireContext())&#10;            .routeLineColorResources(RouteLineColorResources.Builder().build())&#10;            .routeLineBelowLayerId(&quot;road-label-navigation&quot;)&#10;            .build()&#10;        routeLineView = MapboxRouteLineView(routeLineViewOptions)&#10;        routeLineApi = MapboxRouteLineApi(MapboxRouteLineApiOptions.Builder().build())&#10;&#10;        // initialize maneuver arrow view to draw arrows on the map&#10;        val routeArrowOptions = RouteArrowOptions.Builder(requireContext()).build()&#10;        routeArrowView = MapboxRouteArrowView(routeArrowOptions)&#10;&#10;        if (hasLocationPermission()) {&#10;            initializeMap()&#10;        } else {&#10;            requestLocationPermission()&#10;        }&#10;&#10;        val mapboxMap = mapView.mapboxMap&#10;&#10;        // initialize Navigation Camera&#10;        viewportDataSource = MapboxNavigationViewportDataSource(mapboxMap)&#10;        navigationCamera = NavigationCamera(&#10;            mapboxMap,&#10;            mapView.camera,&#10;            viewportDataSource&#10;        )&#10;&#10;        // set the animations lifecycle listener to ensure the NavigationCamera stops&#10;        // automatically following the user location when the map is interacted with&#10;        mapView.camera.addCameraAnimationsLifecycleListener(&#10;            NavigationBasicGesturesHandler(navigationCamera)&#10;        )&#10;        // set the padding values depending to correctly frame maneuvers and the puck&#10;        viewportDataSource.overviewPadding = overviewPadding&#10;        viewportDataSource.followingPadding = followingPadding&#10;&#10;        return mapView&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;    }&#10;&#10;    @Deprecated(&quot;Deprecated in Java&quot;)&#10;    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {&#10;        super.onActivityResult(requestCode, resultCode, data)&#10;        if (requestCode == SEARCH_REQUEST_CODE &amp;&amp; resultCode == AppCompatActivity.RESULT_OK) {&#10;            val locationName = data?.getStringExtra(&quot;location_name&quot;)&#10;            val latitude = data?.getDoubleExtra(&quot;latitude&quot;, 0.0)&#10;            val longitude = data?.getDoubleExtra(&quot;longitude&quot;, 0.0)&#10;&#10;            if (latitude != null &amp;&amp; longitude != null) {&#10;                markLocationOnMap(locationName, latitude, longitude)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun markLocationOnMap(locationName: String?, latitude: Double, longitude: Double) {&#10;        mapManager.getMapView()?.getMapboxMap()?.setCamera(&#10;            CameraOptions.Builder()&#10;                .center(Point.fromLngLat(longitude, latitude))&#10;                .zoom(14.0)&#10;                .build()&#10;        )&#10;&#10;        // Adicionar um marcador no mapa&#10;        val annotationManager = mapManager.getMapView()?.annotations?.createPointAnnotationManager()&#10;        annotationManager?.create(&#10;            PointAnnotationOptions()&#10;                .withPoint(Point.fromLngLat(longitude, latitude))&#10;                .withTextField(locationName ?: &quot;Local&quot;)&#10;        )&#10;    }&#10;&#10;    private fun hasLocationPermission(): Boolean {&#10;        return ContextCompat.checkSelfPermission(&#10;            requireContext(), Manifest.permission.ACCESS_FINE_LOCATION&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    private fun requestLocationPermission() {&#10;        ActivityCompat.requestPermissions(&#10;            requireActivity(),&#10;            arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),&#10;            permissionRequestCode&#10;        )&#10;    }&#10;&#10;    private fun initializeMap() {&#10;        mapManager.getMapView()?.getMapboxMap()?.loadStyleUri(&quot;mapbox://styles/mapbox/streets-v12&quot;) { style -&gt;&#10;            // Associe o LocationProvider do MapView ao navigationLocationProvider&#10;            mapView.location.apply {&#10;                setLocationProvider(navigationLocationProvider)&#10;                enabled = true&#10;            }&#10;            enableLocationComponent()&#10;            restoreCameraState()&#10;            trackCameraChanges()&#10;            mapManager.getMapView()?.compass?.enabled = false&#10;            mapManager.getMapView()?.scalebar?.enabled = false&#10;        }&#10;    }&#10;&#10;    private fun enableLocationComponent() {&#10;        mapManager.getMapView()?.location?.updateSettings {&#10;            enabled = true&#10;        }&#10;    }&#10;&#10;    private fun restoreCameraState() {&#10;        val zoom = preferences.getFloat(&quot;zoom&quot;, 2.0f).toDouble()&#10;        val lat = preferences.getFloat(&quot;latitude&quot;, 39.5f).toDouble()&#10;        val lng = preferences.getFloat(&quot;longitude&quot;, -98.0f).toDouble()&#10;        val pitch = preferences.getFloat(&quot;pitch&quot;, 0.0f).toDouble()&#10;        val bearing = preferences.getFloat(&quot;bearing&quot;, 0.0f).toDouble()&#10;&#10;        val camera = CameraOptions.Builder()&#10;            .zoom(zoom)&#10;            .center(Point.fromLngLat(lng, lat))&#10;            .pitch(pitch)&#10;            .bearing(bearing)&#10;            .build()&#10;&#10;        mapManager.getMapView()?.getMapboxMap()?.setCamera(camera)&#10;    }&#10;&#10;    private fun trackCameraChanges() {&#10;        mapManager.getMapView()?.getMapboxMap()?.addOnCameraChangeListener {&#10;            saveCameraState(mapManager.getMapView()?.getMapboxMap()?.cameraState!!)&#10;        }&#10;    }&#10;&#10;    private fun saveCameraState(state: CameraState) {&#10;        preferences.edit().apply {&#10;            putFloat(&quot;zoom&quot;, state.zoom.toFloat())&#10;            putFloat(&quot;latitude&quot;, state.center.latitude().toFloat())&#10;            putFloat(&quot;longitude&quot;, state.center.longitude().toFloat())&#10;            putFloat(&quot;pitch&quot;, state.pitch.toFloat())&#10;            putFloat(&quot;bearing&quot;, state.bearing.toFloat())&#10;            apply()&#10;        }&#10;    }&#10;&#10;    fun getInstance(): MapaFragment {&#10;        if (instance == null) {&#10;            instance = MapaFragment()&#10;        }&#10;        return instance!!&#10;    }&#10;&#10;    fun addMarker(latitude: Double, longitude: Double) {&#10;        val point = Point.fromLngLat(longitude, latitude)&#10;        mapMarkersManager.showMarker(point, R.drawable.location_pin) // Adiciona o marcador no mapa&#10;    }&#10;&#10;    fun removeLastMarker() {&#10;        mapMarkersManager.removeLastMarker() // Remove o último marcador adicionado&#10;    }&#10;&#10;    fun centralizeUserLocation() {&#10;        val oneTimeListener = OnIndicatorPositionChangedListener { point -&gt;&#10;            val cameraOptions = CameraOptions.Builder()&#10;                .center(point)&#10;                .zoom(15.0)&#10;                .build()&#10;            mapView.mapboxMap.flyTo(cameraOptions)&#10;        }&#10;        mapView.location.addOnIndicatorPositionChangedListener(oneTimeListener)&#10;        mapView.location.removeOnIndicatorPositionChangedListener(oneTimeListener)&#10;    }&#10;&#10;    fun setupMapMoveListener(targetIcon: ImageView) {&#10;        mapView.gestures.addOnMoveListener(&#10;            object : com.mapbox.maps.plugin.gestures.OnMoveListener {&#10;                override fun onMoveBegin(detector: com.mapbox.android.gestures.MoveGestureDetector) {&#10;                    targetIcon.setImageResource(R.drawable.target)&#10;                    targetIcon.setColorFilter(requireContext().getColor(R.color.black))&#10;                }&#10;                override fun onMove(detector: com.mapbox.android.gestures.MoveGestureDetector): Boolean = false&#10;                override fun onMoveEnd(detector: com.mapbox.android.gestures.MoveGestureDetector) {}&#10;            }&#10;        )&#10;    }&#10;&#10;    fun adicionarListenerParaMapa(onPointSelected: (Point) -&gt; Unit) {&#10;        Toast.makeText(requireContext(), &quot;Clique no mapa para selecionar um local&quot;, Toast.LENGTH_SHORT).show()&#10;        mapView.gestures.addOnMapClickListener(&#10;            object : OnMapClickListener {&#10;                override fun onMapClick(point: Point): Boolean {&#10;                    mapMarkersManager.showMarker(point, R.drawable.location_pin)&#10;                    onPointSelected(point)&#10;                    return true&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    fun getMapMarkersManager(): MapMarkersManager = mapMarkersManager&#10;&#10;    fun getUserLocation(callback: (android.location.Location?) -&gt; Unit) {&#10;        val tempLocationObserver = object : LocationObserver {&#10;            override fun onNewRawLocation(rawLocation: Location) {&#10;                // Não utilizado aqui&#10;            }&#10;&#10;            override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {&#10;                // Converte de com.mapbox.common.location.Location para android.location.Location&#10;                val androidLocation = locationMatcherResult.enhancedLocation.toAndroidLocation()&#10;                callback(androidLocation)&#10;                mapboxNavigation.unregisterLocationObserver(this)&#10;            }&#10;        }&#10;        mapboxNavigation.registerLocationObserver(tempLocationObserver)&#10;    }&#10;&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        routeLineApi.cancel()&#10;        routeLineView.cancel()&#10;    }&#10;&#10;    fun requestRoutes(&#10;        origin: Point,&#10;        destinos: List&lt;Destino&gt;,&#10;        onRouteReady: (List&lt;Destino&gt;) -&gt; Unit&#10;    ) {&#10;        val replayRouteMapper = ReplayRouteMapper()&#10;&#10;        // A lista começa pelo origin e segue com todos os destinos (convertendo para Point)&#10;        val points = listOf(origin) + destinos.map { it.localDestino }&#10;&#10;        val routeOptions = RouteOptions.builder()&#10;            .applyDefaultNavigationOptions()&#10;            .applyLanguageAndVoiceUnitOptions(requireContext())&#10;            .coordinatesList(points)&#10;            .alternatives(false)&#10;            .language(&quot;pt&quot;)&#10;            .build()&#10;&#10;        mapboxNavigation.requestRoutes(&#10;            routeOptions,&#10;            object : NavigationRouterCallback {&#10;                override fun onRoutesReady(&#10;                    routes: List&lt;NavigationRoute&gt;,&#10;                    routerOrigin: String&#10;                ) {&#10;                    mapboxNavigation.setNavigationRoutes(routes)&#10;&#10;                    val duration = routes.firstOrNull()?.directionsRoute?.duration()&#10;                        ?: 0.0&#10;&#10;                    val routeCoordinates = routes.firstOrNull()&#10;                        ?.directionsRoute&#10;                        ?.geometry()&#10;                        ?.let { LineString.fromPolyline(it, 6).coordinates() }&#10;                        ?: emptyList()&#10;                    // Mapeia os Points retornados para Destinos (mantendo nome e distância se possível)&#10;                    val destinosAtualizados = destinos.mapIndexed { idx, destino -&gt;&#10;                        if (idx &lt; routeCoordinates.size) destino.copy(localDestino = routeCoordinates[idx]) else destino&#10;                    }&#10;                    onRouteReady(destinosAtualizados)&#10;                }&#10;                override fun onCanceled(routeOptions: RouteOptions, routerOrigin: String) {}&#10;                override fun onFailure(reasons: List&lt;RouterFailure&gt;, routeOptions: RouteOptions) {}&#10;            }&#10;        )&#10;    }&#10;&#10;    fun clearRoutes() {&#10;        mapboxNavigation.setNavigationRoutes(emptyList())&#10;        routeLineApi.clearRouteLine { value -&gt;&#10;            mapView.getMapboxMap().getStyle()?.let { style -&gt;&#10;                routeLineView.renderClearRouteLineValue(style, value)&#10;            }&#10;        }&#10;    }&#10;&#10;    @OptIn(MapboxDelicateApi::class)&#10;    fun updateCamera(originPoint: Point, destinationPoint: Point) {&#10;        val mapAnimationOptions = MapAnimationOptions.Builder().duration(1500L).build()&#10;        val overviewOption = mapView.mapboxMap.cameraForCoordinates(&#10;            listOf(&#10;                originPoint,&#10;                destinationPoint&#10;            ),&#10;            CameraOptions.Builder()&#10;                .padding(EdgeInsets(100.0, 100.0, 100.0, 100.0))&#10;                .build(),&#10;            null,&#10;            null,&#10;            null,&#10;        )&#10;&#10;        mapView.camera.easeTo(&#10;            overviewOption,&#10;            mapAnimationOptions&#10;        )&#10;    }&#10;&#10;    @OptIn(MapboxDelicateApi::class)&#10;    fun updateCamera(origin: Point, destinationPoint: List&lt;Point&gt;){&#10;        val mapAnimationOptions = MapAnimationOptions.Builder().duration(1500L).build()&#10;        val overviewOption = mapView.mapboxMap.cameraForCoordinates(&#10;            listOf(origin) + destinationPoint,&#10;            CameraOptions.Builder()&#10;                .padding(EdgeInsets(100.0, 100.0, 100.0, 100.0))&#10;                .build(),&#10;            null,&#10;            null,&#10;            null,&#10;        )&#10;&#10;        mapView.camera.easeTo(&#10;            overviewOption,&#10;            mapAnimationOptions&#10;        )&#10;    }&#10;&#10;    fun cameraSeguir(){&#10;        navigationCamera.requestNavigationCameraToOverview(&#10;            stateTransitionOptions = NavigationCameraTransitionOptions.Builder()&#10;                .maxDuration(0)&#10;                .build()&#10;        )&#10;    }&#10;&#10;    @OptIn(ExperimentalPreviewMapboxNavigationAPI::class)&#10;     fun startSimulation(route: DirectionsRoute) {&#10;        mapboxNavigation.mapboxReplayer.stop()&#10;        mapboxNavigation.mapboxReplayer.clearEvents()&#10;        val replayData = replayRouteMapper.mapDirectionsRouteGeometry(route)&#10;        mapboxNavigation.mapboxReplayer.pushEvents(replayData)&#10;        mapboxNavigation.mapboxReplayer.seekTo(replayData[0])&#10;        mapboxNavigation.mapboxReplayer.play()&#10;    }&#10;&#10;    @OptIn(ExperimentalPreviewMapboxNavigationAPI::class)&#10;     fun stopSimulation() {&#10;        mapboxNavigation.mapboxReplayer.stop()&#10;        mapboxNavigation.mapboxReplayer.clearEvents()&#10;    }&#10;&#10;&#10;    fun setRouteProgressObserver(observer: RouteProgressObserver) {&#10;        mapboxNavigation.registerRouteProgressObserver(observer)&#10;    }&#10;&#10;    fun removeRouteProgressObserver(observer: RouteProgressObserver) {&#10;        mapboxNavigation.unregisterRouteProgressObserver(observer)&#10;    }&#10;&#10;    fun setVoiceInstructionsObserver(observer: VoiceInstructionsObserver) {&#10;        mapboxNavigation.registerVoiceInstructionsObserver(observer)&#10;    }&#10;&#10;    fun removeVoiceInstructionsObserver(observer: VoiceInstructionsObserver) {&#10;        mapboxNavigation.unregisterVoiceInstructionsObserver(observer)&#10;    }&#10;&#10;    fun initNavigation() {&#10;        MapboxNavigationApp.setup(&#10;            NavigationOptions.Builder(requireContext())&#10;                .build()&#10;        )&#10;&#10;        // initialize location puck&#10;        mapView.location.apply {&#10;            setLocationProvider(navigationLocationProvider)&#10;            this.locationPuck = LocationPuck2D(&#10;                bearingImage = ImageHolder.Companion.from(&#10;                    R.drawable.mapbox_navigation_puck_icon&#10;                )&#10;            )&#10;            puckBearingEnabled = true&#10;            enabled = true&#10;        }&#10;    }&#10;&#10;    // Obtenha o SearchViewModel compartilhado&#10;    private val homeViewModel: HomeViewModel by activityViewModels()&#10;&#10;    fun reverseGeocode(reverseGeoOptions: ReverseGeoOptions, searchCallback: SearchCallback) {&#10;        // Use o searchEngine do SearchViewModel para busca reversa&#10;        homeViewModel.searchEngine.search(&#10;            reverseGeoOptions,&#10;            object : SearchCallback {&#10;                override fun onResults(results: List&lt;SearchResult&gt;, responseInfo: ResponseInfo) {&#10;                    searchCallback.onResults(results, responseInfo)&#10;                }&#10;&#10;                override fun onError(error: Exception) {&#10;                    searchCallback.onError(error)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    fun setOnMapClickListener(listener: (Point) -&gt; Boolean) {&#10;        mapView.mapboxMap.addOnMapClickListener(listener)&#10;    }&#10;&#10;    fun removeOnMapClickListener(listener: (Point) -&gt; Boolean) {&#10;        mapView.mapboxMap.removeOnMapClickListener(listener)&#10;    }&#10;&#10;}" />
              <option name="updatedContent" value="package com.example.pathfinder.ui.components&#10;&#10;import android.Manifest&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.pm.PackageManager&#10;import android.content.res.Resources&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.Toast&#10;import androidx.annotation.RequiresPermission&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.activityViewModels&#10;import com.example.pathfinder.R&#10;import com.example.pathfinder.data.models.Destino&#10;import com.example.pathfinder.ui.home.HomeViewModel&#10;import com.example.pathfinder.ui.searchAc.SearchViewModel&#10;import com.mapbox.api.directions.v5.models.DirectionsRoute&#10;import com.mapbox.api.directions.v5.models.RouteOptions&#10;import com.mapbox.geojson.LineString&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.maps.CameraOptions&#10;import com.mapbox.maps.CameraState&#10;import com.mapbox.maps.MapView&#10;import com.mapbox.maps.Style&#10;import com.mapbox.maps.plugin.animation.flyTo&#10;import com.mapbox.maps.plugin.annotation.annotations&#10;import com.mapbox.maps.plugin.annotation.generated.PointAnnotationOptions&#10;import com.mapbox.maps.plugin.annotation.generated.createPointAnnotationManager&#10;import com.mapbox.maps.plugin.compass.compass&#10;import com.mapbox.maps.plugin.gestures.gestures&#10;import com.mapbox.maps.plugin.locationcomponent.OnIndicatorPositionChangedListener&#10;import com.mapbox.maps.plugin.locationcomponent.location&#10;import com.mapbox.maps.plugin.scalebar.scalebar&#10;import com.mapbox.navigation.base.extensions.applyDefaultNavigationOptions&#10;import com.mapbox.navigation.base.extensions.applyLanguageAndVoiceUnitOptions&#10;import com.mapbox.navigation.core.MapboxNavigation&#10;import com.mapbox.navigation.core.lifecycle.requireMapboxNavigation&#10;import com.mapbox.navigation.core.lifecycle.MapboxNavigationObserver&#10;import com.mapbox.navigation.base.route.NavigationRoute&#10;import com.mapbox.navigation.base.route.NavigationRouterCallback&#10;import com.mapbox.navigation.base.route.RouterFailure&#10;import com.mapbox.navigation.core.directions.session.RoutesObserver&#10;import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineApi&#10;import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineView&#10;import com.mapbox.navigation.ui.maps.route.line.model.NavigationRouteLine&#10;import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineViewOptions&#10;import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineApiOptions&#10;import com.mapbox.navigation.ui.maps.route.line.model.RouteLineColorResources&#10;import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider&#10;import com.mapbox.common.location.toAndroidLocation&#10;import com.mapbox.navigation.core.trip.session.LocationObserver&#10;import com.mapbox.navigation.core.trip.session.LocationMatcherResult&#10;import com.mapbox.common.location.Location&#10;import com.mapbox.maps.EdgeInsets&#10;import com.mapbox.maps.ImageHolder&#10;import com.mapbox.maps.MapboxDelicateApi&#10;import com.mapbox.maps.plugin.LocationPuck2D&#10;import com.mapbox.maps.plugin.animation.MapAnimationOptions&#10;import com.mapbox.maps.plugin.animation.camera&#10;import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI&#10;import com.mapbox.navigation.base.formatter.DistanceFormatterOptions&#10;import com.mapbox.navigation.base.options.NavigationOptions&#10;import com.mapbox.navigation.core.lifecycle.MapboxNavigationApp&#10;import com.mapbox.navigation.core.replay.route.ReplayProgressObserver&#10;import com.mapbox.navigation.core.replay.route.ReplayRouteMapper&#10;import com.mapbox.navigation.core.trip.session.OffRouteObserver&#10;import com.mapbox.navigation.core.trip.session.RouteProgressObserver&#10;import com.mapbox.navigation.core.trip.session.VoiceInstructionsObserver&#10;import com.mapbox.navigation.tripdata.speedlimit.api.MapboxSpeedInfoApi&#10;import com.mapbox.navigation.tripdata.speedlimit.model.SpeedInfoValue&#10;import com.mapbox.navigation.ui.maps.camera.NavigationCamera&#10;import com.mapbox.navigation.ui.maps.camera.data.MapboxNavigationViewportDataSource&#10;import com.mapbox.navigation.ui.maps.camera.lifecycle.NavigationBasicGesturesHandler&#10;import com.mapbox.navigation.ui.maps.camera.state.NavigationCameraState&#10;import com.mapbox.navigation.ui.maps.camera.transition.NavigationCameraTransitionOptions&#10;import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowApi&#10;import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowView&#10;import com.mapbox.navigation.ui.maps.route.arrow.model.RouteArrowOptions&#10;import java.util.Date&#10;import com.mapbox.maps.plugin.gestures.OnMapClickListener&#10;import com.mapbox.maps.plugin.gestures.addOnMapClickListener&#10;import com.mapbox.maps.plugin.gestures.removeOnMapClickListener&#10;import com.mapbox.search.ApiType&#10;import com.mapbox.search.ResponseInfo&#10;import com.mapbox.search.ReverseGeoOptions&#10;import com.mapbox.search.SearchCallback&#10;import com.mapbox.search.SearchEngine&#10;import com.mapbox.search.SearchEngineSettings&#10;import com.mapbox.search.result.SearchResult&#10;&#10;class MapaFragment : Fragment() {&#10;&#10;    lateinit var mapView: MapView&#10;    private val mapManager = MapManeger // Use o MapManager para gerenciar a instância do mapa&#10;    private var instance: MapaFragment? = null&#10;    private lateinit var mapMarkersManager: MapMarkersManager&#10;    private val permissionRequestCode = 1001&#10;    private val SEARCH_REQUEST_CODE = 1001&#10;    private val preferences by lazy {&#10;        requireContext().getSharedPreferences(&quot;map_state&quot;, Context.MODE_PRIVATE)&#10;    }&#10;    // Navigation UI helpers&#10;    val navigationLocationProvider = NavigationLocationProvider()&#10;    private lateinit var routeLineApi: MapboxRouteLineApi&#10;    private lateinit var routeLineView: MapboxRouteLineView&#10;&#10;    var limitInfo: SpeedInfoValue? = null&#10;&#10;    /**&#10;     * Gets notified with location updates.&#10;     *&#10;     * Exposes raw updates coming directly from the location services&#10;     * and the updates enhanced by the Navigation SDK (cleaned up and matched to the road).&#10;     */&#10;    private val locationObserver = object : LocationObserver {&#10;        var firstLocationUpdateReceived = false&#10;&#10;        override fun onNewRawLocation(rawLocation: Location) {&#10;            // not handled&#10;        }&#10;&#10;        override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {&#10;            val enhancedLocation = locationMatcherResult.enhancedLocation&#10;            // update location puck's position on the map&#10;            navigationLocationProvider.changePosition(&#10;                location = enhancedLocation,&#10;                keyPoints = locationMatcherResult.keyPoints,&#10;            )&#10;&#10;            // update camera position to account for new location&#10;            viewportDataSource.onLocationChanged(enhancedLocation)&#10;            viewportDataSource.evaluate()&#10;&#10;            // if this is the first location update the activity has received,&#10;            // it's best to immediately move the camera to the current user location&#10;            if (!firstLocationUpdateReceived) {&#10;                firstLocationUpdateReceived = true&#10;                cameraSeguir()&#10;            }&#10;&#10;            limitInfo = speedInfoApi.updatePostedAndCurrentSpeed(&#10;                locationMatcherResult,&#10;                distanceFormatterOptions&#10;            )&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generates updates for the [routeArrowView] with the geometries and properties of maneuver arrows that should be drawn on the map.&#10;     */&#10;    val routeArrowApi: MapboxRouteArrowApi = MapboxRouteArrowApi()&#10;&#10;    /**&#10;     * Debug observer that makes sure the replayer has always an up-to-date information to generate mock updates.&#10;     */&#10;    private lateinit var replayProgressObserver: ReplayProgressObserver&#10;&#10;    /**&#10;     * Debug object that converts a route into events that can be replayed to navigate a route.&#10;     */&#10;    private val replayRouteMapper = ReplayRouteMapper()&#10;&#10;    // Delegate para o MapboxNavigation conforme recomendado&#10;    @OptIn(ExperimentalPreviewMapboxNavigationAPI::class)&#10;    val mapboxNavigation: MapboxNavigation by requireMapboxNavigation(&#10;        onResumedObserver = object : MapboxNavigationObserver {&#10;            @RequiresPermission(allOf = [Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION])&#10;            override fun onAttached(mapboxNavigation: MapboxNavigation) {&#10;                mapboxNavigation.registerRoutesObserver(routesObserver)&#10;                mapboxNavigation.registerLocationObserver(locationObserver)&#10;                mapboxNavigation.startTripSession()&#10;                mapboxNavigation.registerOffRouteObserver(offRouteObserver)&#10;&#10;                replayProgressObserver = ReplayProgressObserver(mapboxNavigation.mapboxReplayer)&#10;                mapboxNavigation.registerRouteProgressObserver(replayProgressObserver)&#10;            }&#10;            override fun onDetached(mapboxNavigation: MapboxNavigation) {&#10;                mapboxNavigation.unregisterRoutesObserver(routesObserver)&#10;                mapboxNavigation.unregisterLocationObserver(locationObserver)&#10;                mapboxNavigation.unregisterRouteProgressObserver(replayProgressObserver)&#10;                mapboxNavigation.unregisterOffRouteObserver(offRouteObserver)&#10;            }&#10;        }&#10;    )&#10;&#10;    /**&#10;     * Draws maneuver arrows on the map based on the data [routeArrowApi].&#10;     */&#10;    lateinit var routeArrowView: MapboxRouteArrowView&#10;&#10;    val offRouteObserver = object : OffRouteObserver {&#10;        override fun onOffRouteStateChanged(offRoute: Boolean) {&#10;        }&#10;    }&#10;&#10;    private val routesObserver = RoutesObserver { routeUpdateResult -&gt;&#10;        if (routeUpdateResult.navigationRoutes.isNotEmpty()) {&#10;            // generate route geometries asynchronously and render them&#10;            routeLineApi.setNavigationRoutes(&#10;                routeUpdateResult.navigationRoutes&#10;            ) { value -&gt;&#10;                mapView.getMapboxMap().getStyle()?.apply {&#10;                    routeLineView.renderRouteDrawData(this, value)&#10;                }&#10;            }&#10;&#10;            // update the camera position to account for the new route&#10;            viewportDataSource.onRouteChanged(routeUpdateResult.navigationRoutes.first())&#10;            viewportDataSource.evaluate()&#10;        } else {&#10;            // remove the route line and route arrow from the map&#10;            val style = mapView.mapboxMap.style&#10;            if (style != null) {&#10;                routeLineApi.clearRouteLine { value -&gt;&#10;                    routeLineView.renderClearRouteLineValue(&#10;                        style,&#10;                        value&#10;                    )&#10;                }&#10;                routeArrowView.render(style, routeArrowApi.clearArrows())&#10;            }&#10;&#10;            // remove the route reference from camera position evaluations&#10;            viewportDataSource.clearRouteData()&#10;            viewportDataSource.evaluate()&#10;        }&#10;    }&#10;&#10;&#10;    lateinit var navigationCamera: NavigationCamera&#10;    lateinit var viewportDataSource: MapboxNavigationViewportDataSource&#10;    private val pixelDensity = Resources.getSystem().displayMetrics.density&#10;    private val overviewPadding: EdgeInsets by lazy {&#10;        EdgeInsets(&#10;            140.0 * pixelDensity,&#10;            40.0 * pixelDensity,&#10;            120.0 * pixelDensity,&#10;            40.0 * pixelDensity&#10;        )&#10;    }&#10;    private val followingPadding: EdgeInsets by lazy {&#10;        EdgeInsets(&#10;            180.0 * pixelDensity,&#10;            40.0 * pixelDensity,&#10;            150.0 * pixelDensity,&#10;            40.0 * pixelDensity&#10;        )&#10;    }&#10;&#10;    /**&#10;     * API used for formatting speed limit related data.&#10;     */&#10;    private val speedInfoApi: MapboxSpeedInfoApi by lazy {&#10;        MapboxSpeedInfoApi()&#10;    }&#10;&#10;    /**&#10;     * Options used for formatting speed information, such as mph or km/h.&#10;     * By default, the unit type will be determined based on the device's locale.&#10;     */&#10;    private val distanceFormatterOptions: DistanceFormatterOptions by lazy {&#10;        DistanceFormatterOptions.Builder(requireContext()).build()&#10;    }&#10;&#10;&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;&#10;        mapView = MapView(requireContext())&#10;        mapManager.initialize(mapView) // Inicialize o MapManager com o MapView&#10;&#10;        // Inicialize o mapMarkersManager após o mapView estar disponível&#10;        mapMarkersManager = MapMarkersManager(requireContext(), mapView)&#10;&#10;        // Inicialize RouteLineApi e RouteLineView&#10;        val routeLineViewOptions = MapboxRouteLineViewOptions.Builder(requireContext())&#10;            .routeLineColorResources(RouteLineColorResources.Builder().build())&#10;            .routeLineBelowLayerId(&quot;road-label-navigation&quot;)&#10;            .build()&#10;        routeLineView = MapboxRouteLineView(routeLineViewOptions)&#10;        routeLineApi = MapboxRouteLineApi(MapboxRouteLineApiOptions.Builder().build())&#10;&#10;        // initialize maneuver arrow view to draw arrows on the map&#10;        val routeArrowOptions = RouteArrowOptions.Builder(requireContext()).build()&#10;        routeArrowView = MapboxRouteArrowView(routeArrowOptions)&#10;&#10;        if (hasLocationPermission()) {&#10;            initializeMap()&#10;        } else {&#10;            requestLocationPermission()&#10;        }&#10;&#10;        val mapboxMap = mapView.mapboxMap&#10;&#10;        // initialize Navigation Camera&#10;        viewportDataSource = MapboxNavigationViewportDataSource(mapboxMap)&#10;        navigationCamera = NavigationCamera(&#10;            mapboxMap,&#10;            mapView.camera,&#10;            viewportDataSource&#10;        )&#10;&#10;        // set the animations lifecycle listener to ensure the NavigationCamera stops&#10;        // automatically following the user location when the map is interacted with&#10;        mapView.camera.addCameraAnimationsLifecycleListener(&#10;            NavigationBasicGesturesHandler(navigationCamera)&#10;        )&#10;        // set the padding values depending to correctly frame maneuvers and the puck&#10;        viewportDataSource.overviewPadding = overviewPadding&#10;        viewportDataSource.followingPadding = followingPadding&#10;&#10;        return mapView&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;    }&#10;&#10;    @Deprecated(&quot;Deprecated in Java&quot;)&#10;    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {&#10;        super.onActivityResult(requestCode, resultCode, data)&#10;        if (requestCode == SEARCH_REQUEST_CODE &amp;&amp; resultCode == AppCompatActivity.RESULT_OK) {&#10;            val locationName = data?.getStringExtra(&quot;location_name&quot;)&#10;            val latitude = data?.getDoubleExtra(&quot;latitude&quot;, 0.0)&#10;            val longitude = data?.getDoubleExtra(&quot;longitude&quot;, 0.0)&#10;&#10;            if (latitude != null &amp;&amp; longitude != null) {&#10;                markLocationOnMap(locationName, latitude, longitude)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun markLocationOnMap(locationName: String?, latitude: Double, longitude: Double) {&#10;        mapManager.getMapView()?.getMapboxMap()?.setCamera(&#10;            CameraOptions.Builder()&#10;                .center(Point.fromLngLat(longitude, latitude))&#10;                .zoom(14.0)&#10;                .build()&#10;        )&#10;&#10;        // Adicionar um marcador no mapa&#10;        val annotationManager = mapManager.getMapView()?.annotations?.createPointAnnotationManager()&#10;        annotationManager?.create(&#10;            PointAnnotationOptions()&#10;                .withPoint(Point.fromLngLat(longitude, latitude))&#10;                .withTextField(locationName ?: &quot;Local&quot;)&#10;        )&#10;    }&#10;&#10;    private fun hasLocationPermission(): Boolean {&#10;        return ContextCompat.checkSelfPermission(&#10;            requireContext(), Manifest.permission.ACCESS_FINE_LOCATION&#10;        ) == PackageManager.PERMISSION_GRANTED&#10;    }&#10;&#10;    private fun requestLocationPermission() {&#10;        ActivityCompat.requestPermissions(&#10;            requireActivity(),&#10;            arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),&#10;            permissionRequestCode&#10;        )&#10;    }&#10;&#10;    private fun initializeMap() {&#10;        mapManager.getMapView()?.getMapboxMap()?.loadStyleUri(&quot;mapbox://styles/mapbox/streets-v12&quot;) { style -&gt;&#10;            // Associe o LocationProvider do MapView ao navigationLocationProvider&#10;            mapView.location.apply {&#10;                setLocationProvider(navigationLocationProvider)&#10;                enabled = true&#10;            }&#10;            enableLocationComponent()&#10;            restoreCameraState()&#10;            trackCameraChanges()&#10;            mapManager.getMapView()?.compass?.enabled = false&#10;            mapManager.getMapView()?.scalebar?.enabled = false&#10;        }&#10;    }&#10;&#10;    private fun enableLocationComponent() {&#10;        mapManager.getMapView()?.location?.updateSettings {&#10;            enabled = true&#10;        }&#10;    }&#10;&#10;    private fun restoreCameraState() {&#10;        val zoom = preferences.getFloat(&quot;zoom&quot;, 2.0f).toDouble()&#10;        val lat = preferences.getFloat(&quot;latitude&quot;, 39.5f).toDouble()&#10;        val lng = preferences.getFloat(&quot;longitude&quot;, -98.0f).toDouble()&#10;        val pitch = preferences.getFloat(&quot;pitch&quot;, 0.0f).toDouble()&#10;        val bearing = preferences.getFloat(&quot;bearing&quot;, 0.0f).toDouble()&#10;&#10;        val camera = CameraOptions.Builder()&#10;            .zoom(zoom)&#10;            .center(Point.fromLngLat(lng, lat))&#10;            .pitch(pitch)&#10;            .bearing(bearing)&#10;            .build()&#10;&#10;        mapManager.getMapView()?.getMapboxMap()?.setCamera(camera)&#10;    }&#10;&#10;    private fun trackCameraChanges() {&#10;        mapManager.getMapView()?.getMapboxMap()?.addOnCameraChangeListener {&#10;            saveCameraState(mapManager.getMapView()?.getMapboxMap()?.cameraState!!)&#10;        }&#10;    }&#10;&#10;    private fun saveCameraState(state: CameraState) {&#10;        preferences.edit().apply {&#10;            putFloat(&quot;zoom&quot;, state.zoom.toFloat())&#10;            putFloat(&quot;latitude&quot;, state.center.latitude().toFloat())&#10;            putFloat(&quot;longitude&quot;, state.center.longitude().toFloat())&#10;            putFloat(&quot;pitch&quot;, state.pitch.toFloat())&#10;            putFloat(&quot;bearing&quot;, state.bearing.toFloat())&#10;            apply()&#10;        }&#10;    }&#10;&#10;    fun getInstance(): MapaFragment {&#10;        if (instance == null) {&#10;            instance = MapaFragment()&#10;        }&#10;        return instance!!&#10;    }&#10;    fun addMarker(latitude: Double, longitude: Double) {&#10;        val point = Point.fromLngLat(longitude, latitude)&#10;        mapMarkersManager.showMarker(point, R.drawable.location_pin) // Adiciona o marcador no mapa&#10;    }&#10;&#10;    fun removeLastMarker() {&#10;        mapMarkersManager.removeLastMarker() // Remove o último marcador adicionado&#10;    }&#10;&#10;    fun centralizeUserLocation() {&#10;        val oneTimeListener = OnIndicatorPositionChangedListener { point -&gt;&#10;            val cameraOptions = CameraOptions.Builder()&#10;                .center(point)&#10;                .zoom(15.0)&#10;                .build()&#10;            mapView.mapboxMap.flyTo(cameraOptions)&#10;        }&#10;        mapView.location.addOnIndicatorPositionChangedListener(oneTimeListener)&#10;        mapView.location.removeOnIndicatorPositionChangedListener(oneTimeListener)&#10;    }&#10;&#10;    fun setupMapMoveListener(targetIcon: ImageView) {&#10;        mapView.gestures.addOnMoveListener(&#10;            object : com.mapbox.maps.plugin.gestures.OnMoveListener {&#10;                override fun onMoveBegin(detector: com.mapbox.android.gestures.MoveGestureDetector) {&#10;                    targetIcon.setImageResource(R.drawable.target)&#10;                    targetIcon.setColorFilter(requireContext().getColor(R.color.black))&#10;                }&#10;                override fun onMove(detector: com.mapbox.android.gestures.MoveGestureDetector): Boolean = false&#10;                override fun onMoveEnd(detector: com.mapbox.android.gestures.MoveGestureDetector) {}&#10;            }&#10;        )&#10;    }&#10;&#10;    fun adicionarListenerParaMapa(onPointSelected: (Point) -&gt; Unit) {&#10;        Toast.makeText(requireContext(), &quot;Clique no mapa para selecionar um local&quot;, Toast.LENGTH_SHORT).show()&#10;        mapView.gestures.addOnMapClickListener(&#10;            object : OnMapClickListener {&#10;                override fun onMapClick(point: Point): Boolean {&#10;                    mapMarkersManager.showMarker(point, R.drawable.location_pin)&#10;                    onPointSelected(point)&#10;                    return true&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    fun getMapMarkersManager(): MapMarkersManager = mapMarkersManager&#10;&#10;    fun getUserLocation(callback: (android.location.Location?) -&gt; Unit) {&#10;        val tempLocationObserver = object : LocationObserver {&#10;            override fun onNewRawLocation(rawLocation: Location) {&#10;                // Não utilizado aqui&#10;            }&#10;&#10;            override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {&#10;                // Converte de com.mapbox.common.location.Location para android.location.Location&#10;                val androidLocation = locationMatcherResult.enhancedLocation.toAndroidLocation()&#10;                callback(androidLocation)&#10;                mapboxNavigation.unregisterLocationObserver(this)&#10;            }&#10;        }&#10;        mapboxNavigation.registerLocationObserver(tempLocationObserver)&#10;    }&#10;&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        routeLineApi.cancel()&#10;        routeLineView.cancel()&#10;    }&#10;&#10;    fun requestRoutes(&#10;        origin: Point,&#10;        destinos: List&lt;Destino&gt;,&#10;        onRouteReady: (List&lt;Destino&gt;) -&gt; Unit&#10;    ) {&#10;        val replayRouteMapper = ReplayRouteMapper()&#10;&#10;        // A lista começa pelo origin e segue com todos os destinos (convertendo para Point)&#10;        val points = listOf(origin) + destinos.map { it.localDestino }&#10;&#10;        val routeOptions = RouteOptions.builder()&#10;            .applyDefaultNavigationOptions()&#10;            .applyLanguageAndVoiceUnitOptions(requireContext())&#10;            .coordinatesList(points)&#10;            .alternatives(false)&#10;            .language(&quot;pt&quot;)&#10;            .build()&#10;&#10;        mapboxNavigation.requestRoutes(&#10;            routeOptions,&#10;            object : NavigationRouterCallback {&#10;                override fun onRoutesReady(&#10;                    routes: List&lt;NavigationRoute&gt;,&#10;                    routerOrigin: String&#10;                ) {&#10;                    mapboxNavigation.setNavigationRoutes(routes)&#10;&#10;                    val duration = routes.firstOrNull()?.directionsRoute?.duration()&#10;                        ?: 0.0&#10;&#10;                    val routeCoordinates = routes.firstOrNull()&#10;                        ?.directionsRoute&#10;                        ?.geometry()&#10;                        ?.let { LineString.fromPolyline(it, 6).coordinates() }&#10;                        ?: emptyList()&#10;                    // Mapeia os Points retornados para Destinos (mantendo nome e distância se possível)&#10;                    val destinosAtualizados = destinos.mapIndexed { idx, destino -&gt;&#10;                        if (idx &lt; routeCoordinates.size) destino.copy(localDestino = routeCoordinates[idx]) else destino&#10;                    }&#10;                    onRouteReady(destinosAtualizados)&#10;                }&#10;                override fun onCanceled(routeOptions: RouteOptions, routerOrigin: String) {}&#10;                override fun onFailure(reasons: List&lt;RouterFailure&gt;, routeOptions: RouteOptions) {}&#10;            }&#10;        )&#10;    }&#10;&#10;    fun clearRoutes() {&#10;        mapboxNavigation.setNavigationRoutes(emptyList())&#10;        routeLineApi.clearRouteLine { value -&gt;&#10;            mapView.getMapboxMap().getStyle()?.let { style -&gt;&#10;                routeLineView.renderClearRouteLineValue(style, value)&#10;            }&#10;        }&#10;    }&#10;&#10;    @OptIn(MapboxDelicateApi::class)&#10;    fun updateCamera(originPoint: Point, destinationPoint: Point) {&#10;        val mapAnimationOptions = MapAnimationOptions.Builder().duration(1500L).build()&#10;        val overviewOption = mapView.mapboxMap.cameraForCoordinates(&#10;            listOf(&#10;                originPoint,&#10;                destinationPoint&#10;            ),&#10;            CameraOptions.Builder()&#10;                .padding(EdgeInsets(100.0, 100.0, 100.0, 100.0))&#10;                .build(),&#10;            null,&#10;            null,&#10;            null,&#10;        )&#10;&#10;        mapView.camera.easeTo(&#10;            overviewOption,&#10;            mapAnimationOptions&#10;        )&#10;    }&#10;&#10;    @OptIn(MapboxDelicateApi::class)&#10;    fun updateCamera(origin: Point, destinationPoint: List&lt;Point&gt;){&#10;        val mapAnimationOptions = MapAnimationOptions.Builder().duration(1500L).build()&#10;        val overviewOption = mapView.mapboxMap.cameraForCoordinates(&#10;            listOf(origin) + destinationPoint,&#10;            CameraOptions.Builder()&#10;                .padding(EdgeInsets(100.0, 100.0, 100.0, 100.0))&#10;                .build(),&#10;            null,&#10;            null,&#10;            null,&#10;        )&#10;&#10;        mapView.camera.easeTo(&#10;            overviewOption,&#10;            mapAnimationOptions&#10;        )&#10;    }&#10;&#10;    fun cameraSeguir(){&#10;        navigationCamera.requestNavigationCameraToOverview(&#10;            stateTransitionOptions = NavigationCameraTransitionOptions.Builder()&#10;                .maxDuration(0)&#10;                .build()&#10;        )&#10;    }&#10;&#10;    @OptIn(ExperimentalPreviewMapboxNavigationAPI::class)&#10;     fun startSimulation(route: DirectionsRoute) {&#10;        mapboxNavigation.mapboxReplayer.stop()&#10;        mapboxNavigation.mapboxReplayer.clearEvents()&#10;        val replayData = replayRouteMapper.mapDirectionsRouteGeometry(route)&#10;        mapboxNavigation.mapboxReplayer.pushEvents(replayData)&#10;        mapboxNavigation.mapboxReplayer.seekTo(replayData[0])&#10;        mapboxNavigation.mapboxReplayer.play()&#10;    }&#10;&#10;    @OptIn(ExperimentalPreviewMapboxNavigationAPI::class)&#10;     fun stopSimulation() {&#10;        mapboxNavigation.mapboxReplayer.stop()&#10;        mapboxNavigation.mapboxReplayer.clearEvents()&#10;    }&#10;&#10;&#10;    fun setRouteProgressObserver(observer: RouteProgressObserver) {&#10;        mapboxNavigation.registerRouteProgressObserver(observer)&#10;    }&#10;&#10;    fun removeRouteProgressObserver(observer: RouteProgressObserver) {&#10;        mapboxNavigation.unregisterRouteProgressObserver(observer)&#10;    }&#10;&#10;    fun setVoiceInstructionsObserver(observer: VoiceInstructionsObserver) {&#10;        mapboxNavigation.registerVoiceInstructionsObserver(observer)&#10;    }&#10;&#10;    fun removeVoiceInstructionsObserver(observer: VoiceInstructionsObserver) {&#10;        mapboxNavigation.unregisterVoiceInstructionsObserver(observer)&#10;    }&#10;&#10;    fun initNavigation() {&#10;        MapboxNavigationApp.setup(&#10;            NavigationOptions.Builder(requireContext())&#10;                .build()&#10;        )&#10;&#10;        // initialize location puck&#10;        mapView.location.apply {&#10;            setLocationProvider(navigationLocationProvider)&#10;            this.locationPuck = LocationPuck2D(&#10;                bearingImage = ImageHolder.Companion.from(&#10;                    R.drawable.mapbox_navigation_puck_icon&#10;                )&#10;            )&#10;            puckBearingEnabled = true&#10;            enabled = true&#10;        }&#10;    }&#10;&#10;    // Obtenha o SearchViewModel compartilhado&#10;    private val homeViewModel: HomeViewModel by activityViewModels()&#10;&#10;    fun reverseGeocode(reverseGeoOptions: ReverseGeoOptions, searchCallback: SearchCallback) {&#10;        // Use o searchEngine do SearchViewModel para busca reversa&#10;        homeViewModel.searchEngine.search(&#10;            reverseGeoOptions,&#10;            object : SearchCallback {&#10;                override fun onResults(results: List&lt;SearchResult&gt;, responseInfo: ResponseInfo) {&#10;                    searchCallback.onResults(results, responseInfo)&#10;                }&#10;&#10;                override fun onError(error: Exception) {&#10;                    searchCallback.onError(error)&#10;                }&#10;            }&#10;        )&#10;    }&#10;&#10;    fun setOnMapClickListener(listener: (Point) -&gt; Boolean) {&#10;        mapView.mapboxMap.addOnMapClickListener(listener)&#10;    }&#10;&#10;    fun removeOnMapClickListener(listener: (Point) -&gt; Boolean) {&#10;        mapView.mapboxMap.removeOnMapClickListener(listener)&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/pathfinder/ui/home/HomeFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/pathfinder/ui/home/HomeFragment.kt" />
              <option name="originalContent" value="package com.example.pathfinder.ui.home&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.util.TypedValue&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.LinearLayout&#10;import android.widget.PopupMenu&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.view.updateLayoutParams&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.commit&#10;import androidx.fragment.app.activityViewModels&#10;import androidx.navigation.fragment.NavHostFragment&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.pathfinder.R&#10;import com.example.pathfinder.data.models.Destino&#10;import com.example.pathfinder.databinding.FragmentHomeBinding&#10;import com.example.pathfinder.ui.MainActivity&#10;import com.example.pathfinder.ui.components.DestinoAdapter&#10;import com.example.pathfinder.ui.components.MapaBottomSheetFragment&#10;import com.example.pathfinder.ui.components.MapaFragment&#10;import com.example.pathfinder.ui.percorrerRota.RouteFragment&#10;import com.example.pathfinder.ui.searchAc.SearchActivity&#10;import com.example.pathfinder.util.NavigationViewUtils&#10;import com.google.android.material.bottomsheet.BottomSheetBehavior&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.maps.plugin.gestures.addOnMapClickListener&#10;import com.mapbox.maps.plugin.gestures.gestures&#10;import com.mapbox.maps.plugin.gestures.removeOnMapClickListener&#10;import com.mapbox.search.ResponseInfo&#10;import com.mapbox.search.ReverseGeoOptions&#10;import com.mapbox.search.SearchCallback&#10;import com.mapbox.search.result.SearchResult&#10;import com.mapbox.search.ui.view.CommonSearchViewConfiguration&#10;import com.mapbox.search.ui.view.DistanceUnitType&#10;import com.mapbox.search.ui.view.place.SearchPlace&#10;import com.mapbox.search.ui.view.place.SearchPlaceBottomSheetView&#10;import androidx.core.view.isGone&#10;import androidx.fragment.app.viewModels&#10;import com.bumptech.glide.Glide&#10;import com.example.pathfinder.data.models.Usuario&#10;import com.example.pathfinder.data.repositories.RotaRepository&#10;import com.example.pathfinder.data.repositories.UsuarioRepository&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.example.pathfinder.ui.rotas.RotaBottomSheetFragment&#10;import com.example.pathfinder.ui.rotas.RotaSharedViewModel&#10;&#10;&#10;class HomeFragment : Fragment() {&#10;&#10;    companion object {&#10;        private const val REQUEST_CODE_SEARCH = 1001&#10;    }&#10;&#10;    private var _binding: FragmentHomeBinding? = null&#10;    private val binding get() = _binding!!&#10;    private lateinit var targetIcon: ImageView&#10;    private lateinit var searchPlaceView: SearchPlaceBottomSheetView&#10;    private val homeViewModel: HomeViewModel by activityViewModels()&#10;    private val rotaSharedViewModel: RotaSharedViewModel by activityViewModels()&#10;    private lateinit var bottomSheetBehavior: BottomSheetBehavior&lt;LinearLayout&gt;&#10;    private lateinit var destinoAdapter: DestinoAdapter&#10;    private lateinit var txSelecionarDestino: TextView&#10;    private var usuario: Usuario? = null&#10;&#10;    // Variável para armazenar o listener&#10;    private var mapClickListener: ((Point) -&gt; Boolean)? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        val usuarioRepository = UsuarioRepository()&#10;&#10;        usuarioRepository.carregarUsuarioLogado()&#10;        usuarioRepository.usuarioLogado.observe(viewLifecycleOwner) { usuario -&gt;&#10;            this.usuario = usuario&#10;        }&#10;&#10;        targetIcon = binding.root.findViewById(R.id.ac_target)&#10;        searchPlaceView = binding.root.findViewById(R.id.search_place_view)&#10;        searchPlaceView.initialize(CommonSearchViewConfiguration(DistanceUnitType.IMPERIAL))&#10;        &#10;        val bottomSheet = binding.root.findViewById&lt;LinearLayout&gt;(R.id.bottom_sheet_destinos)&#10;        val recyclerView = binding.root.findViewById&lt;RecyclerView&gt;(R.id.recycler_destinos)&#10;        bottomSheetBehavior = bottomSheet?.let { BottomSheetBehavior.from(it) }!!&#10;&#10;        // Definindo os três estados: escondido, colapsado (peek), expandido&#10;        val displayMetrics = resources.displayMetrics&#10;        val navViewHeight = dpToPx(56) // Altura padrão do BottomNavigationView&#10;        val peekHeight = navViewHeight + dpToPx(90) // &quot;Pontinha&quot; acima do navView&#10;        val midHeight = (displayMetrics.heightPixels * 0.35).toInt()&#10;        val expandedHeight = (displayMetrics.heightPixels * 0.85).toInt() // Quase tela cheia&#10;&#10;        val uiContainer = binding.root.findViewById&lt;View&gt;(R.id.ui_container)&#10;&#10;        bottomSheetBehavior.peekHeight = peekHeight&#10;        bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN&#10;&#10;        txSelecionarDestino = binding.root.findViewById(R.id.tx_selecione_destino)&#10;&#10;        // Callback para mudanças de estado do searchPlaceView&#10;        searchPlaceView.addOnBottomSheetStateChangedListener { state, _ -&gt;&#10;            when (state) {&#10;                SearchPlaceBottomSheetView.OPEN -&gt; {&#10;                    txSelecionarDestino.visibility = View.GONE&#10;                    NavigationViewUtils.esconderBottomNavigationView(requireActivity())&#10;&#10;                }&#10;                SearchPlaceBottomSheetView.HIDDEN -&gt; {&#10;                    val destinos = homeViewModel.obterUltimaRota()?.destinosRota ?: emptyList()&#10;                    if(bottomSheetBehavior.state == BottomSheetBehavior.STATE_HIDDEN &amp;&amp; destinos.isEmpty()) {&#10;                        NavigationViewUtils.mostrarBottomNavigationView(requireActivity())&#10;                    } else{&#10;                        bottomSheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED&#10;                    }&#10;                    val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;                    mapaFragment?.removeLastMarker()&#10;                }&#10;                else -&gt; {}&#10;            }&#10;        }&#10;&#10;        bottomSheetBehavior.addBottomSheetCallback(object : BottomSheetBehavior.BottomSheetCallback() {&#10;            override fun onStateChanged(bottomSheet: View, newState: Int) {&#10;                val acTarget = requireView().findViewById&lt;View&gt;(R.id.ac_target)&#10;                val btnIniciarRota = requireView().findViewById&lt;View&gt;(R.id.btn_iniciar_rota)&#10;                val btnSalvarRota = requireView().findViewById&lt;View&gt;(R.id.btn_salvar)&#10;                when (newState) {&#10;                    BottomSheetBehavior.STATE_HIDDEN -&gt; {&#10;                        NavigationViewUtils.mostrarBottomNavigationView(requireActivity())&#10;                        acTarget?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = dpToPx(120)&#10;                        }&#10;                        btnSalvarRota?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = dpToPx(120)&#10;                        }&#10;                        btnIniciarRota?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = dpToPx(119)&#10;                        }&#10;                    }&#10;                    BottomSheetBehavior.STATE_COLLAPSED -&gt; {&#10;                        if(uiContainer.isGone){&#10;                            NavigationViewUtils.mostrarBottomNavigationView(requireActivity())&#10;                        }&#10;                        // Estado colapsado: só a &quot;pontinha&quot; acima do navView&#10;                        bottomSheet.requestLayout()&#10;                        acTarget?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = peekHeight + dpToPx(12)&#10;                        }&#10;                        btnSalvarRota?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = peekHeight + dpToPx(12)&#10;                        }&#10;                        btnIniciarRota?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = peekHeight + dpToPx(11)&#10;                        }&#10;                    }&#10;                    BottomSheetBehavior.STATE_EXPANDED -&gt; {&#10;                        NavigationViewUtils.esconderBottomNavigationView(requireActivity())&#10;                        bottomSheet.layoutParams.height = midHeight&#10;                        bottomSheet.requestLayout()&#10;                        acTarget?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = midHeight + dpToPx(16)&#10;                        }&#10;                        btnSalvarRota.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = midHeight + dpToPx(16)&#10;                        }&#10;                        btnIniciarRota?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = midHeight + dpToPx(16)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            override fun onSlide(bottomSheet: View, slideOffset: Float) {}&#10;        })&#10;&#10;        // Lixeira do destino adapter&#10;        destinoAdapter = DestinoAdapter(emptyList()) { destino -&gt;&#10;            homeViewModel.removerDestinoDaRota(destino)&#10;            val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;            val rota = homeViewModel.obterUltimaRota()&#10;            val origem = rota?.origemRota&#10;            val destinos = rota?.destinosRota&#10;&#10;            if (origem != null &amp;&amp; !destinos.isNullOrEmpty()) {&#10;                mapaFragment?.requestRoutes(origem, destinos){}&#10;                mapaFragment?.updateCamera(origem, destino.localDestino)&#10;            } else {&#10;                mapaFragment?.clearRoutes()&#10;            }&#10;        }&#10;        recyclerView?.adapter = destinoAdapter&#10;        recyclerView?.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        val navHostFragment =&#10;            requireActivity().supportFragmentManager.findFragmentById(R.id.nav_host_fragment_activity_main) as NavHostFragment&#10;        val navController = navHostFragment.navController&#10;&#10;        navController.addOnDestinationChangedListener { _, _, _ -&gt;&#10;            NavigationViewUtils.toggleActionBarForScreen(requireActivity(), true) // para esconder&#10;        }&#10;&#10;        binding.root.findViewById&lt;View&gt;(R.id.btn_iniciar_rota).setOnClickListener{&#10;            esconderComponentes()&#10;            uiContainer.visibility = View.VISIBLE&#10;            childFragmentManager.commit {&#10;                replace(R.id.ui_container, RouteFragment())&#10;            }&#10;            bottomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED&#10;            removerOnMapClickListener()&#10;        }&#10;&#10;        binding.root.findViewById&lt;View&gt;(R.id.search_container).setOnClickListener {&#10;            txSelecionarDestino.visibility = View.GONE&#10;            val intent = Intent(requireContext(), SearchActivity::class.java)&#10;            startActivityForResult(intent, REQUEST_CODE_SEARCH)&#10;            requireActivity().overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)&#10;        }&#10;&#10;        binding.root.findViewById&lt;View&gt;(R.id.search_text).setOnClickListener {&#10;            txSelecionarDestino.visibility = View.GONE&#10;            val intent = Intent(requireContext(), SearchActivity::class.java)&#10;            startActivityForResult(intent, REQUEST_CODE_SEARCH)&#10;            requireActivity().overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)&#10;        }&#10;&#10;        binding.actionProfile.setOnClickListener { view -&gt;&#10;            val popupMenu = PopupMenu(requireContext(), view)&#10;            popupMenu.menuInflater.inflate(R.menu.profile_menu, popupMenu.menu)&#10;            popupMenu.setOnMenuItemClickListener { menuItem -&gt;&#10;                when (menuItem.itemId) {&#10;                    R.id.menu_profile -&gt; {&#10;                        findNavController().navigate(R.id.profileFragment)&#10;                        true&#10;                    }&#10;                    R.id.menu_fechar -&gt; {&#10;                        requireActivity().finish()&#10;                        true&#10;                    }&#10;                    R.id.menu_sair -&gt; {&#10;                        FirebaseAuth.getInstance().signOut()&#10;                        val intent = Intent(requireContext(), MainActivity::class.java)&#10;                        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;                        startActivity(intent)&#10;                        true&#10;                    }&#10;                    else -&gt; false&#10;                }&#10;            }&#10;            popupMenu.show()&#10;        }&#10;&#10;        // Implementar para mostrar uma mensagem se deseja salvar rota e pedir o nome da rota e apos confirmar, salvar a rota com o rotaRepository&#10;        binding.root.findViewById&lt;View&gt;(R.id.btn_salvar).setOnClickListener {&#10;            NavigationViewUtils.mostrarDialogNomeRota({ nomeRota -&gt;&#10;                val rotaAtual = homeViewModel.obterUltimaRota()&#10;                if (rotaAtual != null) {&#10;                    // Atualiza o nome da rota&#10;                    rotaAtual.nomeRota = nomeRota&#10;                    rotaAtual.dtModificacaoRota = Timestamp.now()&#10;                    rotaAtual.distanciaRota = rotaAtual.destinosRota.sumOf { it.distancia ?: 0.0 }&#10;&#10;                    // Salva a rota no Firestore&#10;                    val rotaRepository = RotaRepository()&#10;                    rotaRepository.salvarRota(rotaAtual, {&#10;                        Toast.makeText(requireContext(), &quot;Rota salva com sucesso&quot;, Toast.LENGTH_SHORT).show()&#10;                    } , { exception-&gt;&#10;                        Toast.makeText(requireContext(), &quot;Erro ao salvar rota: ${exception.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                        Log.e(&quot;HomeFragment&quot;, &quot;Erro ao salvar rota&quot;, exception)&#10;                    })&#10;                    homeViewModel.atualizarUltimaRota(rotaAtual)&#10;&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Nenhuma rota para salvar&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }, requireActivity())&#10;        }&#10;&#10;        binding.root.findViewById&lt;View&gt;(R.id.ac_target).setOnClickListener {&#10;            targetIcon.setImageResource(R.drawable.target_variation)&#10;            targetIcon.setColorFilter(resources.getColor(R.color.blue, null))&#10;&#10;            val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as MapaFragment&#10;            mapaFragment.cameraSeguir()&#10;            mapaFragment.setupMapMoveListener(targetIcon)&#10;        }&#10;&#10;        binding.root.findViewById&lt;View&gt;(R.id.map_type_button).setOnClickListener {&#10;            MapaBottomSheetFragment().show(parentFragmentManager, &quot;RotaBottomSheet&quot;)&#10;        }&#10;&#10;        searchPlaceView.addOnCloseClickListener {&#10;            searchPlaceView.hide()&#10;        }&#10;&#10;        searchPlaceView.addOnNavigateClickListener { searchPlace -&gt;&#10;            val destination = Destino(&#10;                nomeDestino = searchPlace.name,&#10;                localDestino = searchPlace.coordinate,&#10;                distancia = searchPlace.distanceMeters&#10;            )&#10;            val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;&#10;            mapaFragment?.getUserLocation { location -&gt;&#10;                if (location != null) {&#10;                    val origin = Point.fromLngLat(location.longitude, location.latitude)&#10;                    val rotaAtual = homeViewModel.obterUltimaRota()&#10;&#10;                    if (rotaAtual != null) {&#10;                        homeViewModel.adicionarDestinoARotaExistente(destination)&#10;                    } else {&#10;                        homeViewModel.criarNovaRota(origin, destination, searchPlace.name, usuario?.idUsuario, searchPlace.distanceMeters)&#10;                    }&#10;&#10;                    val destinos = homeViewModel.obterUltimaRota()?.destinosRota ?: listOf(destination)&#10;                    mapaFragment.requestRoutes(origin, destinos) {&#10;                        //Toast.makeText(requireContext(), &quot;Rota solicitada: $origin&quot;, Toast.LENGTH_SHORT).show()&#10;                        //searchPlaceView.hide()&#10;                        mapaFragment.removeLastMarker()&#10;                    }&#10;                    mapaFragment.updateCamera(origin, destination.localDestino)&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Localização do usuário não disponível&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;        }&#10;&#10;        searchPlaceView.addOnShareClickListener { searchPlace -&gt;&#10;            //startActivity(createShareIntent(searchPlace))&#10;        }&#10;&#10;        homeViewModel.rotas.observe(viewLifecycleOwner) { rotas -&gt;&#10;            val destinos = rotas.lastOrNull()?.destinosRota ?: emptyList()&#10;            showDestinos(destinos)&#10;        }&#10;&#10;        return root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        // Inicializo o MapaFragment&#10;        childFragmentManager.commit {&#10;            replace(R.id.map_container, MapaFragment().getInstance())&#10;        }&#10;&#10;        // Observa rota selecionada do RotaSharedViewModel&#10;        rotaSharedViewModel.rotaSelecionada.observe(viewLifecycleOwner) { rota -&gt;&#10;            rota?.let {&#10;                homeViewModel.substituirRotaAtual(it)&#10;                val destinos = it.destinosRota.orEmpty()&#10;                showDestinos(destinos)&#10;&#10;                val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;                if (mapaFragment != null &amp;&amp; destinos.isNotEmpty()) {&#10;                    mapaFragment.getUserLocation { location -&gt;&#10;                        location?.let { loc -&gt;&#10;                            val origin = Point.fromLngLat(loc.longitude, loc.latitude)&#10;                            mapaFragment.requestRoutes(origin, destinos) {}&#10;                            mapaFragment.updateCamera(origin, destinos.map { d -&gt; d.localDestino })&#10;                        } ?: Log.w(&quot;MapaFragment&quot;, &quot;Localização do usuário indisponível&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Aguarde o commit e o carregamento do mapa&#10;        view.post {&#10;            adicionarOnMapClickListenerParaPesquisa()&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;&#10;    private fun onSearchResultSelected(searchResult: SearchResult, responseInfo: ResponseInfo) {&#10;        val searchPlace = SearchPlace.createFromSearchResult(searchResult, responseInfo)&#10;        searchPlaceView.open(searchPlace)&#10;&#10;        bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN&#10;&#10;        val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;        val coordinate = searchResult.coordinate&#10;        if (mapaFragment != null &amp;&amp; coordinate != null) {&#10;            mapaFragment.addMarker(coordinate.latitude(), coordinate.longitude())&#10;        }&#10;&#10;        NavigationViewUtils.esconderBottomNavigationView(requireActivity())&#10;    }&#10;&#10;    @Deprecated(&quot;Deprecated in Java&quot;)&#10;    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {&#10;        super.onActivityResult(requestCode, resultCode, data)&#10;        if (requestCode == REQUEST_CODE_SEARCH &amp;&amp; resultCode == Activity.RESULT_OK &amp;&amp; data != null) {&#10;            if (data.getBooleanExtra(&quot;request_pesquisarPorClique&quot;, false)) {&#10;                txSelecionarDestino.visibility = View.VISIBLE&#10;                return&#10;            }&#10;            val searchResult = data.getParcelableExtra&lt;SearchResult&gt;(&quot;search_result&quot;)&#10;            val responseInfo = data.getParcelableExtra&lt;ResponseInfo&gt;(&quot;response_info&quot;)&#10;            if (searchResult != null &amp;&amp; responseInfo != null) {&#10;                onSearchResultSelected(searchResult, responseInfo)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun showDestinos(destinos: List&lt;Destino&gt;) {&#10;        destinoAdapter.update(destinos)&#10;        val bottomSheet = requireView().findViewById&lt;LinearLayout&gt;(R.id.bottom_sheet_destinos)&#10;        val btnSalvarRota = requireView().findViewById&lt;View&gt;(R.id.btn_salvar)&#10;        val btnIniciarRota = requireView().findViewById&lt;View&gt;(R.id.btn_iniciar_rota)&#10;        val txNomeRota = binding.root.findViewById&lt;TextView&gt;(R.id.tx_nome_rota)&#10;        val txQtdDestinos = binding.root.findViewById&lt;TextView&gt;(R.id.tx_qtd_destinos)&#10;        val rotaAtual = homeViewModel.obterUltimaRota()&#10;&#10;        if (destinos.isEmpty()) {&#10;            bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN&#10;            btnSalvarRota.visibility = View.GONE&#10;            btnIniciarRota.visibility = View.GONE&#10;        } else {&#10;            // Ao mostrar, começa no estado colapsado (meio)&#10;            val displayMetrics = resources.displayMetrics&#10;            val targetHeight = (displayMetrics.heightPixels * 0.35).toInt()&#10;            bottomSheet.layoutParams.height = targetHeight&#10;            bottomSheet.requestLayout()&#10;            bottomSheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED&#10;            btnSalvarRota.visibility = View.VISIBLE&#10;            btnIniciarRota.visibility = View.VISIBLE&#10;            txNomeRota.text = rotaAtual?.nomeRota&#10;            txQtdDestinos.text = rotaAtual?.destinosRota?.size.toString()&#10;        }&#10;    }&#10;&#10;    private fun dpToPx(dp: Int): Int {&#10;        return TypedValue.applyDimension(&#10;            TypedValue.COMPLEX_UNIT_DIP, dp.toFloat(), resources.displayMetrics&#10;        ).toInt()&#10;    }&#10;&#10;    private fun esconderComponentes() {&#10;        val searchBar = requireView().findViewById&lt;View&gt;(R.id.search_bar)&#10;        val actionProfile = requireView().findViewById&lt;View&gt;(R.id.action_profile)&#10;        val btnIniciarRota = requireView().findViewById&lt;View&gt;(R.id.btn_iniciar_rota)&#10;        val acTarget = requireView().findViewById&lt;View&gt;(R.id.ac_target)&#10;        val btnSalvar = requireView().findViewById&lt;View&gt;(R.id.btn_salvar)&#10;&#10;        txSelecionarDestino.visibility = View.GONE&#10;&#10;        // Animação de fade out e esconder&#10;        listOf(searchBar, actionProfile, btnIniciarRota, btnSalvar, acTarget).forEach { view -&gt;&#10;            view?.animate()&#10;                ?.alpha(0f)&#10;                ?.setDuration(300)&#10;                ?.withEndAction { view.visibility = View.GONE }&#10;                ?.start()&#10;        }&#10;    }&#10;&#10;    fun mostrarComponentes() {&#10;        val searchBar = requireView().findViewById&lt;View&gt;(R.id.search_bar)&#10;        val actionProfile = requireView().findViewById&lt;View&gt;(R.id.action_profile)&#10;        val btnIniciarRota = requireView().findViewById&lt;View&gt;(R.id.btn_iniciar_rota)&#10;        val acTarget = requireView().findViewById&lt;View&gt;(R.id.ac_target)&#10;        val btnSalvar = requireView().findViewById&lt;View&gt;(R.id.btn_salvar)&#10;&#10;        val uiContainer = requireView().findViewById&lt;View&gt;(R.id.ui_container)&#10;        uiContainer.visibility = View.GONE&#10;&#10;        listOf(searchBar, actionProfile, btnIniciarRota, acTarget, btnSalvar).forEach { view -&gt;&#10;            view?.visibility = View.VISIBLE&#10;            view?.animate()?.alpha(1f)?.setDuration(300)?.start()&#10;        }&#10;    }&#10;&#10;     fun adicionarOnMapClickListenerParaPesquisa() {&#10;        val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;        mapClickListener = { point -&gt;&#10;            realizarPesquisaPorPonto(mapaFragment, point)&#10;            true&#10;        }&#10;        mapaFragment?.setOnMapClickListener(mapClickListener!!)&#10;    }&#10;&#10;    private fun removerOnMapClickListener(){&#10;        val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;        mapClickListener?.let { listener -&gt;&#10;            mapaFragment?.removeOnMapClickListener(listener)&#10;            mapClickListener = null&#10;        }&#10;    }&#10;&#10;    private fun realizarPesquisaPorPonto(mapaFragment: MapaFragment?, point: Point) {&#10;        txSelecionarDestino.visibility = View.GONE&#10;        mapaFragment?.getUserLocation { location -&gt;&#10;            if (location != null) {&#10;                mapaFragment.reverseGeocode(ReverseGeoOptions(point), object : SearchCallback {&#10;                    override fun onResults(results: List&lt;SearchResult&gt;, responseInfo: ResponseInfo) {&#10;                        val searchPlace = SearchPlace.createFromSearchResult(results.first(), responseInfo)&#10;                        searchPlaceView.open(searchPlace)&#10;                        bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN&#10;                        mapaFragment.addMarker(point.latitude(), point.longitude())&#10;                    }&#10;&#10;                    override fun onError(error: Exception) {&#10;                        Toast.makeText(requireContext(), &quot;Não foi possível conectar aos serviços da Mapbox. Verifique sua conexão.&quot;, Toast.LENGTH_LONG).show()&#10;                    }&#10;                })&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;Localização do usuário não disponível&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.pathfinder.ui.home&#10;&#10;import android.app.Activity&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.util.TypedValue&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.ImageView&#10;import android.widget.LinearLayout&#10;import android.widget.PopupMenu&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.core.view.updateLayoutParams&#10;import androidx.fragment.app.Fragment&#10;import androidx.fragment.app.commit&#10;import androidx.fragment.app.activityViewModels&#10;import androidx.navigation.fragment.NavHostFragment&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import com.example.pathfinder.R&#10;import com.example.pathfinder.data.models.Destino&#10;import com.example.pathfinder.databinding.FragmentHomeBinding&#10;import com.example.pathfinder.ui.MainActivity&#10;import com.example.pathfinder.ui.components.DestinoAdapter&#10;import com.example.pathfinder.ui.components.MapaBottomSheetFragment&#10;import com.example.pathfinder.ui.components.MapaFragment&#10;import com.example.pathfinder.ui.percorrerRota.RouteFragment&#10;import com.example.pathfinder.ui.searchAc.SearchActivity&#10;import com.example.pathfinder.util.NavigationViewUtils&#10;import com.google.android.material.bottomsheet.BottomSheetBehavior&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.maps.plugin.gestures.addOnMapClickListener&#10;import com.mapbox.maps.plugin.gestures.gestures&#10;import com.mapbox.maps.plugin.gestures.removeOnMapClickListener&#10;import com.mapbox.search.ResponseInfo&#10;import com.mapbox.search.ReverseGeoOptions&#10;import com.mapbox.search.SearchCallback&#10;import com.mapbox.search.result.SearchResult&#10;import com.mapbox.search.ui.view.CommonSearchViewConfiguration&#10;import com.mapbox.search.ui.view.DistanceUnitType&#10;import com.mapbox.search.ui.view.place.SearchPlace&#10;import com.mapbox.search.ui.view.place.SearchPlaceBottomSheetView&#10;import androidx.core.view.isGone&#10;import androidx.fragment.app.viewModels&#10;import com.bumptech.glide.Glide&#10;import com.example.pathfinder.data.models.Usuario&#10;import com.example.pathfinder.data.repositories.RotaRepository&#10;import com.example.pathfinder.data.repositories.UsuarioRepository&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.example.pathfinder.ui.rotas.RotaBottomSheetFragment&#10;import com.example.pathfinder.ui.rotas.RotaSharedViewModel&#10;&#10;&#10;class HomeFragment : Fragment() {&#10;&#10;    companion object {&#10;        private const val REQUEST_CODE_SEARCH = 1001&#10;    }&#10;&#10;    private var _binding: FragmentHomeBinding? = null&#10;    private val binding get() = _binding!!&#10;    private lateinit var targetIcon: ImageView&#10;    private lateinit var searchPlaceView: SearchPlaceBottomSheetView&#10;    private val homeViewModel: HomeViewModel by activityViewModels()&#10;    private val rotaSharedViewModel: RotaSharedViewModel by activityViewModels()&#10;    private lateinit var bottomSheetBehavior: BottomSheetBehavior&lt;LinearLayout&gt;&#10;    private lateinit var destinoAdapter: DestinoAdapter&#10;    private lateinit var txSelecionarDestino: TextView&#10;    private var usuario: Usuario? = null&#10;&#10;    // Variável para armazenar o listener&#10;    private var mapClickListener: ((Point) -&gt; Boolean)? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        val root: View = binding.root&#10;&#10;        val usuarioRepository = UsuarioRepository()&#10;&#10;        usuarioRepository.carregarUsuarioLogado()&#10;        usuarioRepository.usuarioLogado.observe(viewLifecycleOwner) { usuario -&gt;&#10;            this.usuario = usuario&#10;        }&#10;&#10;        targetIcon = binding.root.findViewById(R.id.ac_target)&#10;        searchPlaceView = binding.root.findViewById(R.id.search_place_view)&#10;        searchPlaceView.initialize(CommonSearchViewConfiguration(DistanceUnitType.IMPERIAL))&#10;        &#10;        val bottomSheet = binding.root.findViewById&lt;LinearLayout&gt;(R.id.bottom_sheet_destinos)&#10;        val recyclerView = binding.root.findViewById&lt;RecyclerView&gt;(R.id.recycler_destinos)&#10;        bottomSheetBehavior = bottomSheet?.let { BottomSheetBehavior.from(it) }!!&#10;&#10;        // Definindo os três estados: escondido, colapsado (peek), expandido&#10;        val displayMetrics = resources.displayMetrics&#10;        val navViewHeight = dpToPx(56) // Altura padrão do BottomNavigationView&#10;        val peekHeight = navViewHeight + dpToPx(90) // &quot;Pontinha&quot; acima do navView&#10;        val midHeight = (displayMetrics.heightPixels * 0.35).toInt()&#10;        val expandedHeight = (displayMetrics.heightPixels * 0.85).toInt() // Quase tela cheia&#10;&#10;        val uiContainer = binding.root.findViewById&lt;View&gt;(R.id.ui_container)&#10;&#10;        bottomSheetBehavior.peekHeight = peekHeight&#10;        bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN&#10;&#10;        txSelecionarDestino = binding.root.findViewById(R.id.tx_selecione_destino)&#10;&#10;        // Callback para mudanças de estado do searchPlaceView&#10;        searchPlaceView.addOnBottomSheetStateChangedListener { state, _ -&gt;&#10;            when (state) {&#10;                SearchPlaceBottomSheetView.OPEN -&gt; {&#10;                    txSelecionarDestino.visibility = View.GONE&#10;                    NavigationViewUtils.esconderBottomNavigationView(requireActivity())&#10;&#10;                }&#10;                SearchPlaceBottomSheetView.HIDDEN -&gt; {&#10;                    val destinos = homeViewModel.obterUltimaRota()?.destinosRota ?: emptyList()&#10;                    if(bottomSheetBehavior.state == BottomSheetBehavior.STATE_HIDDEN &amp;&amp; destinos.isEmpty()) {&#10;                        NavigationViewUtils.mostrarBottomNavigationView(requireActivity())&#10;                    } else{&#10;                        bottomSheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED&#10;                    }&#10;                    val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;                    mapaFragment?.removeLastMarker()&#10;                }&#10;                else -&gt; {}&#10;            }&#10;        }&#10;&#10;        bottomSheetBehavior.addBottomSheetCallback(object : BottomSheetBehavior.BottomSheetCallback() {&#10;            override fun onStateChanged(bottomSheet: View, newState: Int) {&#10;                val acTarget = requireView().findViewById&lt;View&gt;(R.id.ac_target)&#10;                val btnIniciarRota = requireView().findViewById&lt;View&gt;(R.id.btn_iniciar_rota)&#10;                val btnSalvarRota = requireView().findViewById&lt;View&gt;(R.id.btn_salvar)&#10;                when (newState) {&#10;                    BottomSheetBehavior.STATE_HIDDEN -&gt; {&#10;                        NavigationViewUtils.mostrarBottomNavigationView(requireActivity())&#10;                        acTarget?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = dpToPx(120)&#10;                        }&#10;                        btnSalvarRota?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = dpToPx(120)&#10;                        }&#10;                        btnIniciarRota?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = dpToPx(119)&#10;                        }&#10;                    }&#10;                    BottomSheetBehavior.STATE_COLLAPSED -&gt; {&#10;                        if(uiContainer.isGone){&#10;                            NavigationViewUtils.mostrarBottomNavigationView(requireActivity())&#10;                        }&#10;                        // Estado colapsado: só a &quot;pontinha&quot; acima do navView&#10;                        bottomSheet.requestLayout()&#10;                        acTarget?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = peekHeight + dpToPx(12)&#10;                        }&#10;                        btnSalvarRota?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = peekHeight + dpToPx(12)&#10;                        }&#10;                        btnIniciarRota?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = peekHeight + dpToPx(11)&#10;                        }&#10;                    }&#10;                    BottomSheetBehavior.STATE_EXPANDED -&gt; {&#10;                        NavigationViewUtils.esconderBottomNavigationView(requireActivity())&#10;                        bottomSheet.layoutParams.height = midHeight&#10;                        bottomSheet.requestLayout()&#10;                        acTarget?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = midHeight + dpToPx(16)&#10;                        }&#10;                        btnSalvarRota.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = midHeight + dpToPx(16)&#10;                        }&#10;                        btnIniciarRota?.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; {&#10;                            bottomMargin = midHeight + dpToPx(16)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            override fun onSlide(bottomSheet: View, slideOffset: Float) {}&#10;        })&#10;&#10;        // Lixeira do destino adapter&#10;        destinoAdapter = DestinoAdapter(emptyList()) { destino -&gt;&#10;            homeViewModel.removerDestinoDaRota(destino)&#10;            val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;            val rota = homeViewModel.obterUltimaRota()&#10;            val origem = rota?.origemRota&#10;            val destinos = rota?.destinosRota&#10;&#10;            if (origem != null &amp;&amp; !destinos.isNullOrEmpty()) {&#10;                mapaFragment?.requestRoutes(origem, destinos){}&#10;                mapaFragment?.updateCamera(origem, destino.localDestino)&#10;            } else {&#10;                mapaFragment?.clearRoutes()&#10;            }&#10;        }&#10;        recyclerView?.adapter = destinoAdapter&#10;        recyclerView?.layoutManager = LinearLayoutManager(requireContext())&#10;&#10;        val navHostFragment =&#10;            requireActivity().supportFragmentManager.findFragmentById(R.id.nav_host_fragment_activity_main) as NavHostFragment&#10;        val navController = navHostFragment.navController&#10;&#10;        navController.addOnDestinationChangedListener { _, _, _ -&gt;&#10;            NavigationViewUtils.toggleActionBarForScreen(requireActivity(), true) // para esconder&#10;        }&#10;&#10;        binding.root.findViewById&lt;View&gt;(R.id.btn_iniciar_rota).setOnClickListener{&#10;            esconderComponentes()&#10;            uiContainer.visibility = View.VISIBLE&#10;            childFragmentManager.commit {&#10;                replace(R.id.ui_container, RouteFragment())&#10;            }&#10;            bottomSheetBehavior.state = BottomSheetBehavior.STATE_COLLAPSED&#10;            removerOnMapClickListener()&#10;        }&#10;&#10;        binding.root.findViewById&lt;View&gt;(R.id.search_container).setOnClickListener {&#10;            txSelecionarDestino.visibility = View.GONE&#10;            val intent = Intent(requireContext(), SearchActivity::class.java)&#10;            startActivityForResult(intent, REQUEST_CODE_SEARCH)&#10;            requireActivity().overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)&#10;        }&#10;&#10;        binding.root.findViewById&lt;View&gt;(R.id.search_text).setOnClickListener {&#10;            txSelecionarDestino.visibility = View.GONE&#10;            val intent = Intent(requireContext(), SearchActivity::class.java)&#10;            startActivityForResult(intent, REQUEST_CODE_SEARCH)&#10;            requireActivity().overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out)&#10;        }&#10;&#10;        binding.actionProfile.setOnClickListener { view -&gt;&#10;            val popupMenu = PopupMenu(requireContext(), view)&#10;            popupMenu.menuInflater.inflate(R.menu.profile_menu, popupMenu.menu)&#10;            popupMenu.setOnMenuItemClickListener { menuItem -&gt;&#10;                when (menuItem.itemId) {&#10;                    R.id.menu_profile -&gt; {&#10;                        findNavController().navigate(R.id.profileFragment)&#10;                        true&#10;                    }&#10;                    R.id.menu_fechar -&gt; {&#10;                        requireActivity().finish()&#10;                        true&#10;                    }&#10;                    R.id.menu_sair -&gt; {&#10;                        FirebaseAuth.getInstance().signOut()&#10;                        val intent = Intent(requireContext(), MainActivity::class.java)&#10;                        intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK&#10;                        startActivity(intent)&#10;                        true&#10;                    }&#10;                    else -&gt; false&#10;                }&#10;            }&#10;            popupMenu.show()&#10;        }&#10;&#10;        // Implementar para mostrar uma mensagem se deseja salvar rota e pedir o nome da rota e apos confirmar, salvar a rota com o rotaRepository&#10;        binding.root.findViewById&lt;View&gt;(R.id.btn_salvar).setOnClickListener {&#10;            NavigationViewUtils.mostrarDialogNomeRota({ nomeRota -&gt;&#10;                val rotaAtual = homeViewModel.obterUltimaRota()&#10;                if (rotaAtual != null) {&#10;                    // Atualiza o nome da rota&#10;                    rotaAtual.nomeRota = nomeRota&#10;                    rotaAtual.dtModificacaoRota = Timestamp.now()&#10;                    rotaAtual.distanciaRota = rotaAtual.destinosRota.sumOf { it.distancia ?: 0.0 }&#10;&#10;                    // Salva a rota no Firestore&#10;                    val rotaRepository = RotaRepository()&#10;                    rotaRepository.salvarRota(rotaAtual, {&#10;                        Toast.makeText(requireContext(), &quot;Rota salva com sucesso&quot;, Toast.LENGTH_SHORT).show()&#10;                    } , { exception-&gt;&#10;                        Toast.makeText(requireContext(), &quot;Erro ao salvar rota: ${exception.message}&quot;, Toast.LENGTH_SHORT).show()&#10;                        Log.e(&quot;HomeFragment&quot;, &quot;Erro ao salvar rota&quot;, exception)&#10;                    })&#10;                    homeViewModel.atualizarUltimaRota(rotaAtual)&#10;&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Nenhuma rota para salvar&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }, requireActivity())&#10;        }&#10;&#10;        binding.root.findViewById&lt;View&gt;(R.id.ac_target).setOnClickListener {&#10;            targetIcon.setImageResource(R.drawable.target_variation)&#10;            targetIcon.setColorFilter(resources.getColor(R.color.blue, null))&#10;&#10;            val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as MapaFragment&#10;            mapaFragment.cameraSeguir()&#10;            mapaFragment.setupMapMoveListener(targetIcon)&#10;        }&#10;&#10;        binding.root.findViewById&lt;View&gt;(R.id.map_type_button).setOnClickListener {&#10;            MapaBottomSheetFragment().show(parentFragmentManager, &quot;RotaBottomSheet&quot;)&#10;        }&#10;&#10;        searchPlaceView.addOnCloseClickListener {&#10;            searchPlaceView.hide()&#10;        }&#10;&#10;        searchPlaceView.addOnNavigateClickListener { searchPlace -&gt;&#10;            val destination = Destino(&#10;                nomeDestino = searchPlace.name,&#10;                localDestino = searchPlace.coordinate,&#10;                distancia = searchPlace.distanceMeters&#10;            )&#10;            val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;&#10;            mapaFragment?.getUserLocation { location -&gt;&#10;                if (location != null) {&#10;                    val origin = Point.fromLngLat(location.longitude, location.latitude)&#10;                    val rotaAtual = homeViewModel.obterUltimaRota()&#10;&#10;                    if (rotaAtual != null) {&#10;                        homeViewModel.adicionarDestinoARotaExistente(destination)&#10;                    } else {&#10;                        homeViewModel.criarNovaRota(origin, destination, searchPlace.name, usuario?.idUsuario, searchPlace.distanceMeters)&#10;                    }&#10;&#10;                    val destinos = homeViewModel.obterUltimaRota()?.destinosRota ?: listOf(destination)&#10;                    mapaFragment.requestRoutes(origin, destinos) {&#10;                        //Toast.makeText(requireContext(), &quot;Rota solicitada: $origin&quot;, Toast.LENGTH_SHORT).show()&#10;                        //searchPlaceView.hide()&#10;                        mapaFragment.removeLastMarker()&#10;                    }&#10;                    mapaFragment.updateCamera(origin, destination.localDestino)&#10;                } else {&#10;                    Toast.makeText(requireContext(), &quot;Localização do usuário não disponível&quot;, Toast.LENGTH_SHORT).show()&#10;                }&#10;            }&#10;        }&#10;&#10;        searchPlaceView.addOnShareClickListener { searchPlace -&gt;&#10;            //startActivity(createShareIntent(searchPlace))&#10;        }&#10;&#10;        homeViewModel.rotas.observe(viewLifecycleOwner) { rotas -&gt;&#10;            val destinos = rotas.lastOrNull()?.destinosRota ?: emptyList()&#10;            showDestinos(destinos)&#10;        }&#10;&#10;        return root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        // Inicializo o MapaFragment&#10;        childFragmentManager.commit {&#10;            replace(R.id.map_container, MapaFragment().getInstance())&#10;        }&#10;&#10;        // Observa rota selecionada do RotaSharedViewModel&#10;        rotaSharedViewModel.rotaSelecionada.observe(viewLifecycleOwner) { rota -&gt;&#10;            rota?.let {&#10;                homeViewModel.substituirRotaAtual(it)&#10;                val destinos = it.destinosRota.orEmpty()&#10;                showDestinos(destinos)&#10;&#10;                val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;                if (mapaFragment != null &amp;&amp; destinos.isNotEmpty()) {&#10;                    mapaFragment.getUserLocation { location -&gt;&#10;                        location?.let { loc -&gt;&#10;                            val origin = Point.fromLngLat(loc.longitude, loc.latitude)&#10;                            mapaFragment.requestRoutes(origin, destinos) {}&#10;                            mapaFragment.updateCamera(origin, destinos.map { d -&gt; d.localDestino })&#10;                        } ?: Log.w(&quot;MapaFragment&quot;, &quot;Localização do usuário indisponível&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Aguarde o commit e o carregamento do mapa&#10;        view.post {&#10;            adicionarOnMapClickListenerParaPesquisa()&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        _binding = null&#10;    }&#10;&#10;    private fun onSearchResultSelected(searchResult: SearchResult, responseInfo: ResponseInfo) {&#10;        val searchPlace = SearchPlace.createFromSearchResult(searchResult, responseInfo)&#10;        searchPlaceView.open(searchPlace)&#10;&#10;        bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN&#10;&#10;        val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;        val coordinate = searchResult.coordinate&#10;        if (mapaFragment != null &amp;&amp; coordinate != null) {&#10;            mapaFragment.addMarker(coordinate.latitude(), coordinate.longitude())&#10;        }&#10;&#10;        NavigationViewUtils.esconderBottomNavigationView(requireActivity())&#10;    }&#10;&#10;    @Deprecated(&quot;Deprecated in Java&quot;)&#10;    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {&#10;        super.onActivityResult(requestCode, resultCode, data)&#10;        if (requestCode == REQUEST_CODE_SEARCH &amp;&amp; resultCode == Activity.RESULT_OK &amp;&amp; data != null) {&#10;            if (data.getBooleanExtra(&quot;request_pesquisarPorClique&quot;, false)) {&#10;                txSelecionarDestino.visibility = View.VISIBLE&#10;                return&#10;            }&#10;            val searchResult = data.getParcelableExtra&lt;SearchResult&gt;(&quot;search_result&quot;)&#10;            val responseInfo = data.getParcelableExtra&lt;ResponseInfo&gt;(&quot;response_info&quot;)&#10;            if (searchResult != null &amp;&amp; responseInfo != null) {&#10;                onSearchResultSelected(searchResult, responseInfo)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun showDestinos(destinos: List&lt;Destino&gt;) {&#10;        destinoAdapter.update(destinos)&#10;        val bottomSheet = requireView().findViewById&lt;LinearLayout&gt;(R.id.bottom_sheet_destinos)&#10;        val btnSalvarRota = requireView().findViewById&lt;View&gt;(R.id.btn_salvar)&#10;        val btnIniciarRota = requireView().findViewById&lt;View&gt;(R.id.btn_iniciar_rota)&#10;        val txNomeRota = binding.root.findViewById&lt;TextView&gt;(R.id.tx_nome_rota)&#10;        val txQtdDestinos = binding.root.findViewById&lt;TextView&gt;(R.id.tx_qtd_destinos)&#10;        val rotaAtual = homeViewModel.obterUltimaRota()&#10;&#10;        if (destinos.isEmpty()) {&#10;            bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN&#10;            btnSalvarRota.visibility = View.GONE&#10;            btnIniciarRota.visibility = View.GONE&#10;        } else {&#10;            // Ao mostrar, começa no estado colapsado (meio)&#10;            val displayMetrics = resources.displayMetrics&#10;            val targetHeight = (displayMetrics.heightPixels * 0.35).toInt()&#10;            bottomSheet.layoutParams.height = targetHeight&#10;            bottomSheet.requestLayout()&#10;            bottomSheetBehavior.state = BottomSheetBehavior.STATE_EXPANDED&#10;            btnSalvarRota.visibility = View.VISIBLE&#10;            btnIniciarRota.visibility = View.VISIBLE&#10;            txNomeRota.text = rotaAtual?.nomeRota&#10;            txQtdDestinos.text = rotaAtual?.destinosRota?.size.toString()&#10;        }&#10;    }&#10;&#10;    private fun dpToPx(dp: Int): Int {&#10;        return TypedValue.applyDimension(&#10;            TypedValue.COMPLEX_UNIT_DIP, dp.toFloat(), resources.displayMetrics&#10;        ).toInt()&#10;    }&#10;&#10;    private fun esconderComponentes() {&#10;        val searchBar = requireView().findViewById&lt;View&gt;(R.id.search_bar)&#10;        val actionProfile = requireView().findViewById&lt;View&gt;(R.id.action_profile)&#10;        val btnIniciarRota = requireView().findViewById&lt;View&gt;(R.id.btn_iniciar_rota)&#10;        val acTarget = requireView().findViewById&lt;View&gt;(R.id.ac_target)&#10;        val btnSalvar = requireView().findViewById&lt;View&gt;(R.id.btn_salvar)&#10;&#10;        txSelecionarDestino.visibility = View.GONE&#10;&#10;        // Animação de fade out e esconder&#10;        listOf(searchBar, actionProfile, btnIniciarRota, btnSalvar, acTarget).forEach { view -&gt;&#10;            view?.animate()&#10;                ?.alpha(0f)&#10;                ?.setDuration(300)&#10;                ?.withEndAction { view.visibility = View.GONE }&#10;                ?.start()&#10;        }&#10;    }&#10;&#10;    fun mostrarComponentes() {&#10;        val searchBar = requireView().findViewById&lt;View&gt;(R.id.search_bar)&#10;        val actionProfile = requireView().findViewById&lt;View&gt;(R.id.action_profile)&#10;        val btnIniciarRota = requireView().findViewById&lt;View&gt;(R.id.btn_iniciar_rota)&#10;        val acTarget = requireView().findViewById&lt;View&gt;(R.id.ac_target)&#10;        val btnSalvar = requireView().findViewById&lt;View&gt;(R.id.btn_salvar)&#10;&#10;        val uiContainer = requireView().findViewById&lt;View&gt;(R.id.ui_container)&#10;        uiContainer.visibility = View.GONE&#10;&#10;        listOf(searchBar, actionProfile, btnIniciarRota, acTarget, btnSalvar).forEach { view -&gt;&#10;            view?.visibility = View.VISIBLE&#10;            view?.animate()?.alpha(1f)?.setDuration(300)?.start()&#10;        }&#10;    }&#10;&#10;     fun adicionarOnMapClickListenerParaPesquisa() {&#10;        val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;        mapClickListener = { point -&gt;&#10;            realizarPesquisaPorPonto(mapaFragment, point)&#10;            true&#10;        }&#10;        mapaFragment?.setOnMapClickListener(mapClickListener!!)&#10;    }&#10;&#10;    private fun removerOnMapClickListener(){&#10;        val mapaFragment = childFragmentManager.findFragmentById(R.id.map_container) as? MapaFragment&#10;        mapClickListener?.let { listener -&gt;&#10;            mapaFragment?.removeOnMapClickListener(listener)&#10;            mapClickListener = null&#10;        }&#10;    }&#10;&#10;    private fun realizarPesquisaPorPonto(mapaFragment: MapaFragment?, point: Point) {&#10;        txSelecionarDestino.visibility = View.GONE&#10;        mapaFragment?.getUserLocation { location -&gt;&#10;            if (location != null) {&#10;                mapaFragment.reverseGeocode(ReverseGeoOptions(point), object : SearchCallback {&#10;                    override fun onResults(results: List&lt;SearchResult&gt;, responseInfo: ResponseInfo) {&#10;                        val searchPlace = SearchPlace.createFromSearchResult(results.first(), responseInfo)&#10;                        searchPlaceView.open(searchPlace)&#10;                        bottomSheetBehavior.state = BottomSheetBehavior.STATE_HIDDEN&#10;                        mapaFragment.addMarker(point.latitude(), point.longitude())&#10;                    }&#10;&#10;                    override fun onError(error: Exception) {&#10;                        Toast.makeText(requireContext(), &quot;Não foi possível conectar aos serviços da Mapbox. Verifique sua conexão.&quot;, Toast.LENGTH_LONG).show()&#10;                    }&#10;                })&#10;            } else {&#10;                Toast.makeText(requireContext(), &quot;Localização do usuário não disponível&quot;, Toast.LENGTH_SHORT).show()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun getDestinoAdapter(): DestinoAdapter {&#10;        return destinoAdapter&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/pathfinder/ui/percorrerRota/RouteFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/pathfinder/ui/percorrerRota/RouteFragment.kt" />
              <option name="originalContent" value="package com.example.pathfinder.ui.percorrerRota&#10;&#10;import androidx.fragment.app.activityViewModels&#10;import androidx.fragment.app.viewModels&#10;import android.os.Bundle&#10;import androidx.fragment.app.Fragment&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.core.view.isVisible&#10;import com.example.pathfinder.R&#10;import com.example.pathfinder.ui.components.MapaFragment&#10;import com.example.pathfinder.data.models.Rota&#10;import com.example.pathfinder.databinding.FragmentRouteBinding&#10;import com.example.pathfinder.ui.components.DestinoAdapter&#10;import com.example.pathfinder.ui.home.HomeFragment&#10;import com.example.pathfinder.ui.home.HomeViewModel&#10;import com.example.pathfinder.util.NavigationViewUtils&#10;import com.mapbox.api.directions.v5.models.DirectionsRoute&#10;import com.mapbox.api.directions.v5.models.RouteOptions&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.api.matching.v5.MapboxMapMatching&#10;import com.mapbox.api.matching.v5.models.MapMatchingResponse&#10;import com.mapbox.api.directions.v5.DirectionsCriteria&#10;import com.mapbox.bindgen.Expected&#10;import com.mapbox.maps.ImageHolder&#10;import com.mapbox.maps.plugin.LocationPuck2D&#10;import com.mapbox.maps.plugin.locationcomponent.location&#10;import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI&#10;import com.mapbox.navigation.base.TimeFormat&#10;import com.mapbox.navigation.base.formatter.DistanceFormatterOptions&#10;import com.mapbox.navigation.core.formatter.MapboxDistanceFormatter&#10;import com.mapbox.navigation.core.replay.route.ReplayProgressObserver&#10;import com.mapbox.navigation.core.trip.session.RouteProgressObserver&#10;import com.mapbox.navigation.core.trip.session.VoiceInstructionsObserver&#10;import com.mapbox.navigation.tripdata.maneuver.api.MapboxManeuverApi&#10;import com.mapbox.navigation.tripdata.progress.api.MapboxTripProgressApi&#10;import com.mapbox.navigation.tripdata.progress.model.DistanceRemainingFormatter&#10;import com.mapbox.navigation.tripdata.progress.model.EstimatedTimeToArrivalFormatter&#10;import com.mapbox.navigation.tripdata.progress.model.PercentDistanceTraveledFormatter&#10;import com.mapbox.navigation.tripdata.progress.model.TimeRemainingFormatter&#10;import com.mapbox.navigation.tripdata.progress.model.TripProgressUpdateFormatter&#10;import com.mapbox.navigation.tripdata.speedlimit.api.MapboxSpeedInfoApi&#10;import com.mapbox.navigation.ui.base.util.MapboxNavigationConsumer&#10;import com.mapbox.navigation.ui.components.tripprogress.model.TripProgressViewOptions&#10;import com.mapbox.navigation.ui.components.tripprogress.view.MapboxTripProgressView&#10;import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowApi&#10;import com.mapbox.navigation.voice.api.MapboxSpeechApi&#10;import com.mapbox.navigation.voice.api.MapboxVoiceInstructionsPlayer&#10;import com.mapbox.navigation.voice.model.SpeechAnnouncement&#10;import com.mapbox.navigation.voice.model.SpeechError&#10;import com.mapbox.navigation.voice.model.SpeechValue&#10;import com.mapbox.navigation.voice.model.SpeechVolume&#10;import retrofit2.Call&#10;import retrofit2.Callback&#10;import retrofit2.Response&#10;import java.util.Locale&#10;import com.mapbox.maps.plugin.locationcomponent.createDefault2DPuck&#10;import androidx.recyclerview.widget.RecyclerView&#10;&#10;class RouteFragment : Fragment() {&#10;    private val homeViewModel: HomeViewModel by activityViewModels()&#10;    private lateinit var mapaFragment: MapaFragment&#10;    private var rota: Rota? = null&#10;    private var _binding: FragmentRouteBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private companion object {&#10;        private const val BUTTON_ANIMATION_DURATION = 1500L&#10;    }&#10;&#10;    /**&#10;     * Generates updates for the [MapboxManeuverView] to display the upcoming maneuver instructions&#10;     * and remaining distance to the maneuver point.&#10;     */&#10;    private lateinit var maneuverApi: MapboxManeuverApi&#10;&#10;    /**&#10;     * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to the destination.&#10;     */&#10;    private lateinit var tripProgressApi: MapboxTripProgressApi&#10;&#10;    /**&#10;     * Gets notified with progress along the currently active route.&#10;     */&#10;    private val routeProgressObserver = RouteProgressObserver { routeProgress -&gt;&#10;        // update the camera position to account for the progressed fragment of the route&#10;        mapaFragment.viewportDataSource.onRouteProgressChanged(routeProgress)&#10;        mapaFragment.viewportDataSource.evaluate()&#10;&#10;        // draw the upcoming maneuver arrow on the map&#10;        val style = mapaFragment.mapView.mapboxMap.style&#10;        if (style != null) {&#10;            val maneuverArrowResult = mapaFragment.routeArrowApi.addUpcomingManeuverArrow(routeProgress)&#10;            mapaFragment.routeArrowView.renderManeuverUpdate(style, maneuverArrowResult)&#10;        }&#10;&#10;        // update top banner with maneuver instructions&#10;        val maneuvers = maneuverApi.getManeuvers(routeProgress)&#10;        maneuvers.fold(&#10;            { error -&gt;&#10;                Toast.makeText(&#10;                    requireContext(),&#10;                    error.errorMessage,&#10;                    Toast.LENGTH_SHORT&#10;                ).show()&#10;            },&#10;            {&#10;                binding.maneuverView.visibility = View.VISIBLE&#10;                binding.maneuverView.renderManeuvers(maneuvers)&#10;            }&#10;        )&#10;&#10;        // update bottom trip progress summary&#10;        val routeInfoContainer = requireActivity().findViewById&lt;ViewGroup&gt;(R.id.route_info_container)&#10;        val tripProgressView = routeInfoContainer.findViewById&lt;MapboxTripProgressView&gt;(R.id.tripProgressView)&#10;        tripProgressView?.render(&#10;            tripProgressApi.getTripProgress(routeProgress)&#10;        )&#10;    }&#10;&#10;&#10;    /**&#10;     * Extracts message that should be communicated to the driver about the upcoming maneuver.&#10;     * When possible, downloads a synthesized audio file that can be played back to the driver.&#10;     */&#10;    private lateinit var speechApi: MapboxSpeechApi&#10;&#10;    /**&#10;     * Plays the synthesized audio files with upcoming maneuver instructions&#10;     * or uses an on-device Text-To-Speech engine to communicate the message to the driver.&#10;     * NOTE: do not use lazy initialization for this class since it takes some time to initialize&#10;     * the system services required for on-device speech synthesis. With lazy initialization&#10;     * there is a high risk that said services will not be available when the first instruction&#10;     * has to be played. [MapboxVoiceInstructionsPlayer] should be instantiated in&#10;     * `Activity#onCreate`.&#10;     */&#10;    private lateinit var voiceInstructionsPlayer: MapboxVoiceInstructionsPlayer&#10;&#10;    /**&#10;     * When a synthesized audio file was downloaded, this callback cleans up the disk after it was played.&#10;     */&#10;    private val voiceInstructionsPlayerCallback =&#10;        MapboxNavigationConsumer&lt;SpeechAnnouncement&gt; { value -&gt;&#10;            // remove already consumed file to free-up space&#10;            speechApi.clean(value)&#10;        }&#10;&#10;    /**&#10;     * Based on whether the synthesized audio file is available, the callback plays the file&#10;     * or uses the fall back which is played back using the on-device Text-To-Speech engine.&#10;     */&#10;    private val speechCallback =&#10;        MapboxNavigationConsumer&lt;Expected&lt;SpeechError, SpeechValue&gt;&gt; { expected -&gt;&#10;            expected.fold(&#10;                { error -&gt;&#10;                    // play the instruction via fallback text-to-speech engine&#10;                    voiceInstructionsPlayer.play(&#10;                        error.fallback,&#10;                        voiceInstructionsPlayerCallback&#10;                    )&#10;                },&#10;                { value -&gt;&#10;                    // play the sound file from the external generator&#10;                    voiceInstructionsPlayer.play(&#10;                        value.announcement,&#10;                        voiceInstructionsPlayerCallback&#10;                    )&#10;                }&#10;            )&#10;        }&#10;&#10;    /**&#10;     * Stores and updates the state of whether the voice instructions should be played as they come or muted.&#10;     */&#10;    private var isVoiceInstructionsMuted = false&#10;        set(value) {&#10;            field = value&#10;            if (value) {&#10;                binding.soundButton.muteAndExtend(BUTTON_ANIMATION_DURATION)&#10;                voiceInstructionsPlayer.volume(SpeechVolume(0f))&#10;            } else {&#10;                binding.soundButton.unmuteAndExtend(BUTTON_ANIMATION_DURATION)&#10;                voiceInstructionsPlayer.volume(SpeechVolume(1f))&#10;            }&#10;        }&#10;&#10;&#10;    /**&#10;     * Observes when a new voice instruction should be played.&#10;     */&#10;    private val voiceInstructionsObserver = VoiceInstructionsObserver { voiceInstructions -&gt;&#10;        speechApi.generate(voiceInstructions, speechCallback)&#10;    }&#10;&#10;    private lateinit var destinoAdapter: DestinoAdapter&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // TODO: Use the ViewModel&#10;    }&#10;&#10;    private lateinit var tripProgressCard: View&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentRouteBinding.inflate(inflater, container, false)&#10;        // Recupera a última rota do HomeViewModel&#10;        rota = homeViewModel.obterUltimaRota()&#10;&#10;        NavigationViewUtils.esconderBottomNavigationView(requireActivity())&#10;&#10;        // Altere a cor da status bar (barra superior)&#10;        //requireActivity().window.statusBarColor = resources.getColor(R.color.blue_gray, null)&#10;&#10;        // Altere a cor da navigation bar (barra inferior)&#10;        //requireActivity().window.navigationBarColor = resources.getColor(R.color.white, null)&#10;&#10;        // Se precisar do mapa, recupere o fragmento já existente&#10;        mapaFragment = (requireParentFragment()&#10;            .childFragmentManager&#10;            .findFragmentById(R.id.map_container) as? MapaFragment)!!&#10;&#10;        // make sure to use the same DistanceFormatterOptions across different features&#10;        val distanceFormatterOptions = DistanceFormatterOptions.Builder(requireContext()).build()&#10;&#10;        // Infla o item_inforota no route_info_container&#10;        val routeInfoContainer = requireActivity().findViewById&lt;ViewGroup&gt;(R.id.route_info_container)&#10;        val inflater = LayoutInflater.from(requireContext())&#10;        val infoView = inflater.inflate(R.layout.item_inforota, routeInfoContainer, false)&#10;&#10;        // Referencie corretamente os elementos do item_inforota&#10;        tripProgressCard = infoView.findViewById(R.id.tripProgressCard)&#10;        val tripProgressView = infoView.findViewById&lt;MapboxTripProgressView&gt;(R.id.tripProgressView)&#10;        val stopButton = infoView.findViewById&lt;View&gt;(R.id.stop)&#10;&#10;        val options = TripProgressViewOptions.Builder()&#10;            .backgroundColor(R.color.white_gray)&#10;            .distanceRemainingTextAppearance(R.style.TripProgressTextCentered)&#10;            // Adicione outras customizações aqui&#10;            .build()&#10;&#10;        tripProgressView.updateOptions(options)&#10;&#10;        tripProgressCard.visibility = View.VISIBLE&#10;&#10;        // initialize maneuver api that feeds the data to the top banner maneuver view&#10;        maneuverApi = MapboxManeuverApi(&#10;            MapboxDistanceFormatter(distanceFormatterOptions)&#10;        )&#10;&#10;        // initialize bottom progress view&#10;        tripProgressApi = MapboxTripProgressApi(&#10;            TripProgressUpdateFormatter.Builder(requireContext())&#10;                .distanceRemainingFormatter(&#10;                    DistanceRemainingFormatter(distanceFormatterOptions)&#10;                )&#10;                .timeRemainingFormatter(&#10;                    TimeRemainingFormatter(requireContext())&#10;                )&#10;                .percentRouteTraveledFormatter(&#10;                    PercentDistanceTraveledFormatter()&#10;                )&#10;                .estimatedTimeToArrivalFormatter(&#10;                    EstimatedTimeToArrivalFormatter(requireContext(), TimeFormat.NONE_SPECIFIED)&#10;                )&#10;                .build()&#10;        )&#10;&#10;        // initialize voice instructions api and the voice instruction player&#10;        speechApi = MapboxSpeechApi(&#10;            requireContext(),&#10;            &quot;pt-BR&quot;&#10;        )&#10;        voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(&#10;            requireContext(),&#10;            &quot;pt-BR&quot;&#10;        )&#10;&#10;        // initialize view interactions&#10;        stopButton.setOnClickListener {&#10;            encerrarFragmento()&#10;        }&#10;        binding.recenter.setOnClickListener {&#10;            mapaFragment.navigationCamera.requestNavigationCameraToFollowing()&#10;            binding.recenter.showTextAndExtend(BUTTON_ANIMATION_DURATION)&#10;        }&#10;        binding.routeOverview.setOnClickListener {&#10;            mapaFragment.navigationCamera.requestNavigationCameraToOverview()&#10;            binding.routeOverview.showTextAndExtend(BUTTON_ANIMATION_DURATION)&#10;        }&#10;        binding.soundButton.setOnClickListener {&#10;            // mute/unmute voice instructions&#10;            isVoiceInstructionsMuted = !isVoiceInstructionsMuted&#10;        }&#10;&#10;        // set initial sounds button state&#10;        binding.soundButton.unmute()&#10;&#10;        routeInfoContainer.addView(infoView)&#10;&#10;        // Obtenha o destinoAdapter do HomeFragment&#10;        val homeFragment = requireParentFragment() as? HomeFragment&#10;        destinoAdapter = homeFragment?.getDestinoAdapter() ?: throw IllegalStateException(&quot;DestinoAdapter não encontrado&quot;)&#10;&#10;        // Verifique se está vazio ao criar a view&#10;        if (destinoAdapter.getDestinos().isEmpty()) {&#10;            // Encerra o fragmento imediatamente&#10;            view?.post { encerrarFragmento() }&#10;            return binding.root&#10;        }&#10;&#10;        // Registre o observer APÓS tudo estar pronto&#10;        // Remova qualquer registro duplicado em outros lugares&#10;        mapaFragment.setRouteProgressObserver(routeProgressObserver)&#10;&#10;        mapaFragment.setVoiceInstructionsObserver(voiceInstructionsObserver)&#10;&#10;        // initialize location puck&#10;        mapaFragment.mapView.location.apply {&#10;            setLocationProvider(mapaFragment.navigationLocationProvider)&#10;            this.locationPuck = LocationPuck2D(&#10;                bearingImage = ImageHolder.Companion.from(&#10;                    R.drawable.mapbox_navigation_puck_icon&#10;                )&#10;            )&#10;            puckBearingEnabled = true&#10;            enabled = true&#10;        }&#10;&#10;        // show UI elements&#10;        binding.soundButton.visibility = View.VISIBLE&#10;        binding.routeOverview.visibility = View.VISIBLE&#10;        //binding.tripProgressCard.visibility = View.VISIBLE&#10;        mapaFragment.cameraSeguir()&#10;        // Chame o método para obter DirectionsRoute e simular&#10;        rota?.let { rotaObj -&gt;&#10;            val accessToken = getString(R.string.mapbox_access_token)&#10;            solicitarDirectionsRouteViaMapMatching(rotaObj, accessToken) { directionsRoute -&gt;&#10;                directionsRoute?.let {&#10;                    mapaFragment.startSimulation(it)&#10;                }&#10;            }&#10;        }&#10;&#10;        if (mapaFragment.limitInfo != null) {&#10;            binding.speedLimitView.isVisible = true&#10;            binding.speedLimitView.render(mapaFragment.limitInfo!!)&#10;        } else {&#10;            binding.speedLimitView.isVisible = false&#10;        }&#10;&#10;        mapaFragment.navigationCamera.requestNavigationCameraToFollowing()&#10;&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        // Observe mudanças na lista de destinos e encerre se ficar vazio&#10;        destinoAdapter.registerAdapterDataObserver(object : RecyclerView.AdapterDataObserver() {&#10;            override fun onChanged() {&#10;                if (destinoAdapter.getDestinos().isEmpty()) {&#10;                    encerrarFragmento()&#10;                }&#10;            }&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                if (destinoAdapter.getDestinos().isEmpty()) {&#10;                    encerrarFragmento()&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    /**&#10;     * Solicita uma DirectionsRoute válida usando o Map Matching API.&#10;     */&#10;    private fun solicitarDirectionsRouteViaMapMatching(rota: Rota, accessToken: String, onResult: (DirectionsRoute?) -&gt; Unit) {&#10;        val pontos = listOf(rota.origemRota) + rota.destinosRota.map { it.localDestino }&#10;&#10;        val mapMatchingRequest = MapboxMapMatching.builder()&#10;            .accessToken(accessToken)&#10;            .coordinates(pontos)&#10;            .steps(true)&#10;            .voiceInstructions(true)&#10;            .bannerInstructions(true)&#10;            .profile(DirectionsCriteria.PROFILE_DRIVING)&#10;            .build()&#10;&#10;        mapMatchingRequest.enqueueCall(object : Callback&lt;MapMatchingResponse&gt; {&#10;            override fun onResponse(call: Call&lt;MapMatchingResponse&gt;, response: Response&lt;MapMatchingResponse&gt;) {&#10;                if (response.isSuccessful) {&#10;                    val directionsRoute = response.body()?.matchings()?.firstOrNull()?.toDirectionRoute()&#10;                    onResult(directionsRoute)&#10;                } else {&#10;                    onResult(null)&#10;                }&#10;            }&#10;            override fun onFailure(call: Call&lt;MapMatchingResponse&gt;, throwable: Throwable) {&#10;                onResult(null)&#10;            }&#10;        })&#10;    }&#10;&#10;    private fun clearRouteAndStopNavigation() {&#10;        // clear&#10;        //mapaFragment.mapboxNavigation.setNavigationRoutes(listOf())&#10;&#10;        // Limpa as setas&#10;        mapaFragment.routeArrowApi.clearArrows()&#10;&#10;        // stop simulation&#10;        mapaFragment.stopSimulation()&#10;&#10;        // hide UI elements&#10;        binding.soundButton.visibility = View.INVISIBLE&#10;        binding.maneuverView.visibility = View.INVISIBLE&#10;        binding.routeOverview.visibility = View.INVISIBLE&#10;        tripProgressCard.visibility = View.GONE&#10;    }&#10;&#10;    private fun encerrarFragmento(){&#10;        // Limpa rota e para navegação&#10;        clearRouteAndStopNavigation()&#10;&#10;        // Reverta o navigation puck para o estado original&#10;        mapaFragment.mapView.location.apply {&#10;            setLocationProvider(mapaFragment.navigationLocationProvider)&#10;            this.locationPuck = createDefault2DPuck()&#10;            puckBearingEnabled = true&#10;            enabled = true&#10;        }&#10;&#10;        // Remove todas as views do route_info_container para evitar duplicidade&#10;        val routeInfoContainer = requireActivity().findViewById&lt;ViewGroup&gt;(R.id.route_info_container)&#10;        routeInfoContainer.removeAllViews()&#10;&#10;        // Mostra novamente os componentes da HomeFragment&#10;        val homeFragment = requireParentFragment() as? HomeFragment&#10;        homeFragment?.let {&#10;            it.mostrarComponentes()&#10;            it.adicionarOnMapClickListenerParaPesquisa()&#10;            NavigationViewUtils.mostrarBottomNavigationView(requireActivity())&#10;        }&#10;&#10;        // Remove RouteFragment&#10;        parentFragmentManager.beginTransaction()&#10;            .remove(this)&#10;            .commit()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        // Remova o observer apenas aqui&#10;        mapaFragment.removeRouteProgressObserver(routeProgressObserver)&#10;        mapaFragment.removeVoiceInstructionsObserver(voiceInstructionsObserver)&#10;        maneuverApi.cancel()&#10;        speechApi.cancel()&#10;        voiceInstructionsPlayer.shutdown()&#10;        _binding = null&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.pathfinder.ui.percorrerRota&#10;&#10;import androidx.fragment.app.activityViewModels&#10;import androidx.fragment.app.viewModels&#10;import android.os.Bundle&#10;import androidx.fragment.app.Fragment&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Toast&#10;import androidx.core.view.isVisible&#10;import com.example.pathfinder.R&#10;import com.example.pathfinder.ui.components.MapaFragment&#10;import com.example.pathfinder.data.models.Rota&#10;import com.example.pathfinder.databinding.FragmentRouteBinding&#10;import com.example.pathfinder.ui.components.DestinoAdapter&#10;import com.example.pathfinder.ui.home.HomeFragment&#10;import com.example.pathfinder.ui.home.HomeViewModel&#10;import com.example.pathfinder.util.NavigationViewUtils&#10;import com.mapbox.api.directions.v5.models.DirectionsRoute&#10;import com.mapbox.api.directions.v5.models.RouteOptions&#10;import com.mapbox.geojson.Point&#10;import com.mapbox.api.matching.v5.MapboxMapMatching&#10;import com.mapbox.api.matching.v5.models.MapMatchingResponse&#10;import com.mapbox.api.directions.v5.DirectionsCriteria&#10;import com.mapbox.bindgen.Expected&#10;import com.mapbox.maps.ImageHolder&#10;import com.mapbox.maps.plugin.LocationPuck2D&#10;import com.mapbox.maps.plugin.locationcomponent.location&#10;import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI&#10;import com.mapbox.navigation.base.TimeFormat&#10;import com.mapbox.navigation.base.formatter.DistanceFormatterOptions&#10;import com.mapbox.navigation.core.formatter.MapboxDistanceFormatter&#10;import com.mapbox.navigation.core.replay.route.ReplayProgressObserver&#10;import com.mapbox.navigation.core.trip.session.RouteProgressObserver&#10;import com.mapbox.navigation.core.trip.session.VoiceInstructionsObserver&#10;import com.mapbox.navigation.tripdata.maneuver.api.MapboxManeuverApi&#10;import com.mapbox.navigation.tripdata.progress.api.MapboxTripProgressApi&#10;import com.mapbox.navigation.tripdata.progress.model.DistanceRemainingFormatter&#10;import com.mapbox.navigation.tripdata.progress.model.EstimatedTimeToArrivalFormatter&#10;import com.mapbox.navigation.tripdata.progress.model.PercentDistanceTraveledFormatter&#10;import com.mapbox.navigation.tripdata.progress.model.TimeRemainingFormatter&#10;import com.mapbox.navigation.tripdata.progress.model.TripProgressUpdateFormatter&#10;import com.mapbox.navigation.tripdata.speedlimit.api.MapboxSpeedInfoApi&#10;import com.mapbox.navigation.ui.base.util.MapboxNavigationConsumer&#10;import com.mapbox.navigation.ui.components.tripprogress.model.TripProgressViewOptions&#10;import com.mapbox.navigation.ui.components.tripprogress.view.MapboxTripProgressView&#10;import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowApi&#10;import com.mapbox.navigation.voice.api.MapboxSpeechApi&#10;import com.mapbox.navigation.voice.api.MapboxVoiceInstructionsPlayer&#10;import com.mapbox.navigation.voice.model.SpeechAnnouncement&#10;import com.mapbox.navigation.voice.model.SpeechError&#10;import com.mapbox.navigation.voice.model.SpeechValue&#10;import com.mapbox.navigation.voice.model.SpeechVolume&#10;import retrofit2.Call&#10;import retrofit2.Callback&#10;import retrofit2.Response&#10;import java.util.Locale&#10;import com.mapbox.maps.plugin.locationcomponent.createDefault2DPuck&#10;import androidx.recyclerview.widget.RecyclerView&#10;&#10;class RouteFragment : Fragment() {&#10;    private val homeViewModel: HomeViewModel by activityViewModels()&#10;    private lateinit var mapaFragment: MapaFragment&#10;    private var rota: Rota? = null&#10;    private var _binding: FragmentRouteBinding? = null&#10;    private val binding get() = _binding!!&#10;&#10;    private companion object {&#10;        private const val BUTTON_ANIMATION_DURATION = 1500L&#10;    }&#10;&#10;    /**&#10;     * Generates updates for the [MapboxManeuverView] to display the upcoming maneuver instructions&#10;     * and remaining distance to the maneuver point.&#10;     */&#10;    private lateinit var maneuverApi: MapboxManeuverApi&#10;&#10;    /**&#10;     * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to the destination.&#10;     */&#10;    private lateinit var tripProgressApi: MapboxTripProgressApi&#10;&#10;    /**&#10;     * Gets notified with progress along the currently active route.&#10;     */&#10;    private val routeProgressObserver = RouteProgressObserver { routeProgress -&gt;&#10;        // update the camera position to account for the progressed fragment of the route&#10;        mapaFragment.viewportDataSource.onRouteProgressChanged(routeProgress)&#10;        mapaFragment.viewportDataSource.evaluate()&#10;&#10;        // draw the upcoming maneuver arrow on the map&#10;        val style = mapaFragment.mapView.mapboxMap.style&#10;        if (style != null) {&#10;            val maneuverArrowResult = mapaFragment.routeArrowApi.addUpcomingManeuverArrow(routeProgress)&#10;            mapaFragment.routeArrowView.renderManeuverUpdate(style, maneuverArrowResult)&#10;        }&#10;&#10;        // update top banner with maneuver instructions&#10;        val maneuvers = maneuverApi.getManeuvers(routeProgress)&#10;        maneuvers.fold(&#10;            { error -&gt;&#10;                Toast.makeText(&#10;                    requireContext(),&#10;                    error.errorMessage,&#10;                    Toast.LENGTH_SHORT&#10;                ).show()&#10;            },&#10;            {&#10;                binding.maneuverView.visibility = View.VISIBLE&#10;                binding.maneuverView.renderManeuvers(maneuvers)&#10;            }&#10;        )&#10;&#10;        // update bottom trip progress summary&#10;        val routeInfoContainer = requireActivity().findViewById&lt;ViewGroup&gt;(R.id.route_info_container)&#10;        val tripProgressView = routeInfoContainer.findViewById&lt;MapboxTripProgressView&gt;(R.id.tripProgressView)&#10;        tripProgressView?.render(&#10;            tripProgressApi.getTripProgress(routeProgress)&#10;        )&#10;    }&#10;&#10;&#10;    /**&#10;     * Extracts message that should be communicated to the driver about the upcoming maneuver.&#10;     * When possible, downloads a synthesized audio file that can be played back to the driver.&#10;     */&#10;    private lateinit var speechApi: MapboxSpeechApi&#10;&#10;    /**&#10;     * Plays the synthesized audio files with upcoming maneuver instructions&#10;     * or uses an on-device Text-To-Speech engine to communicate the message to the driver.&#10;     * NOTE: do not use lazy initialization for this class since it takes some time to initialize&#10;     * the system services required for on-device speech synthesis. With lazy initialization&#10;     * there is a high risk that said services will not be available when the first instruction&#10;     * has to be played. [MapboxVoiceInstructionsPlayer] should be instantiated in&#10;     * `Activity#onCreate`.&#10;     */&#10;    private lateinit var voiceInstructionsPlayer: MapboxVoiceInstructionsPlayer&#10;&#10;    /**&#10;     * When a synthesized audio file was downloaded, this callback cleans up the disk after it was played.&#10;     */&#10;    private val voiceInstructionsPlayerCallback =&#10;        MapboxNavigationConsumer&lt;SpeechAnnouncement&gt; { value -&gt;&#10;            // remove already consumed file to free-up space&#10;            speechApi.clean(value)&#10;        }&#10;&#10;    /**&#10;     * Based on whether the synthesized audio file is available, the callback plays the file&#10;     * or uses the fall back which is played back using the on-device Text-To-Speech engine.&#10;     */&#10;    private val speechCallback =&#10;        MapboxNavigationConsumer&lt;Expected&lt;SpeechError, SpeechValue&gt;&gt; { expected -&gt;&#10;            expected.fold(&#10;                { error -&gt;&#10;                    // play the instruction via fallback text-to-speech engine&#10;                    voiceInstructionsPlayer.play(&#10;                        error.fallback,&#10;                        voiceInstructionsPlayerCallback&#10;                    )&#10;                },&#10;                { value -&gt;&#10;                    // play the sound file from the external generator&#10;                    voiceInstructionsPlayer.play(&#10;                        value.announcement,&#10;                        voiceInstructionsPlayerCallback&#10;                    )&#10;                }&#10;            )&#10;        }&#10;&#10;    /**&#10;     * Stores and updates the state of whether the voice instructions should be played as they come or muted.&#10;     */&#10;    private var isVoiceInstructionsMuted = false&#10;        set(value) {&#10;            field = value&#10;            if (value) {&#10;                binding.soundButton.muteAndExtend(BUTTON_ANIMATION_DURATION)&#10;                voiceInstructionsPlayer.volume(SpeechVolume(0f))&#10;            } else {&#10;                binding.soundButton.unmuteAndExtend(BUTTON_ANIMATION_DURATION)&#10;                voiceInstructionsPlayer.volume(SpeechVolume(1f))&#10;            }&#10;        }&#10;&#10;&#10;    /**&#10;     * Observes when a new voice instruction should be played.&#10;     */&#10;    private val voiceInstructionsObserver = VoiceInstructionsObserver { voiceInstructions -&gt;&#10;        speechApi.generate(voiceInstructions, speechCallback)&#10;    }&#10;&#10;    private lateinit var destinoAdapter: DestinoAdapter&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // TODO: Use the ViewModel&#10;    }&#10;&#10;    private lateinit var tripProgressCard: View&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View {&#10;        _binding = FragmentRouteBinding.inflate(inflater, container, false)&#10;        // Recupera a última rota do HomeViewModel&#10;        rota = homeViewModel.obterUltimaRota()&#10;&#10;        NavigationViewUtils.esconderBottomNavigationView(requireActivity())&#10;&#10;        // Altere a cor da status bar (barra superior)&#10;        //requireActivity().window.statusBarColor = resources.getColor(R.color.blue_gray, null)&#10;&#10;        // Altere a cor da navigation bar (barra inferior)&#10;        //requireActivity().window.navigationBarColor = resources.getColor(R.color.white, null)&#10;&#10;        // Se precisar do mapa, recupere o fragmento já existente&#10;        mapaFragment = (requireParentFragment()&#10;            .childFragmentManager&#10;            .findFragmentById(R.id.map_container) as? MapaFragment)!!&#10;&#10;        // make sure to use the same DistanceFormatterOptions across different features&#10;        val distanceFormatterOptions = DistanceFormatterOptions.Builder(requireContext()).build()&#10;&#10;        // Infla o item_inforota no route_info_container&#10;        val routeInfoContainer = requireActivity().findViewById&lt;ViewGroup&gt;(R.id.route_info_container)&#10;        val inflater = LayoutInflater.from(requireContext())&#10;        val infoView = inflater.inflate(R.layout.item_inforota, routeInfoContainer, false)&#10;&#10;        // Referencie corretamente os elementos do item_inforota&#10;        tripProgressCard = infoView.findViewById(R.id.tripProgressCard)&#10;        val tripProgressView = infoView.findViewById&lt;MapboxTripProgressView&gt;(R.id.tripProgressView)&#10;        val stopButton = infoView.findViewById&lt;View&gt;(R.id.stop)&#10;&#10;        val options = TripProgressViewOptions.Builder()&#10;            .backgroundColor(R.color.white_gray)&#10;            .distanceRemainingTextAppearance(R.style.TripProgressTextCentered)&#10;            // Adicione outras customizações aqui&#10;            .build()&#10;&#10;        tripProgressView.updateOptions(options)&#10;&#10;        tripProgressCard.visibility = View.VISIBLE&#10;&#10;        // initialize maneuver api that feeds the data to the top banner maneuver view&#10;        maneuverApi = MapboxManeuverApi(&#10;            MapboxDistanceFormatter(distanceFormatterOptions)&#10;        )&#10;&#10;        // initialize bottom progress view&#10;        tripProgressApi = MapboxTripProgressApi(&#10;            TripProgressUpdateFormatter.Builder(requireContext())&#10;                .distanceRemainingFormatter(&#10;                    DistanceRemainingFormatter(distanceFormatterOptions)&#10;                )&#10;                .timeRemainingFormatter(&#10;                    TimeRemainingFormatter(requireContext())&#10;                )&#10;                .percentRouteTraveledFormatter(&#10;                    PercentDistanceTraveledFormatter()&#10;                )&#10;                .estimatedTimeToArrivalFormatter(&#10;                    EstimatedTimeToArrivalFormatter(requireContext(), TimeFormat.NONE_SPECIFIED)&#10;                )&#10;                .build()&#10;        )&#10;&#10;        // initialize voice instructions api and the voice instruction player&#10;        speechApi = MapboxSpeechApi(&#10;            requireContext(),&#10;            &quot;pt-BR&quot;&#10;        )&#10;        voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(&#10;            requireContext(),&#10;            &quot;pt-BR&quot;&#10;        )&#10;&#10;        // initialize view interactions&#10;        stopButton.setOnClickListener {&#10;            encerrarFragmento()&#10;        }&#10;        binding.recenter.setOnClickListener {&#10;            mapaFragment.navigationCamera.requestNavigationCameraToFollowing()&#10;            binding.recenter.showTextAndExtend(BUTTON_ANIMATION_DURATION)&#10;        }&#10;        binding.routeOverview.setOnClickListener {&#10;            mapaFragment.navigationCamera.requestNavigationCameraToOverview()&#10;            binding.routeOverview.showTextAndExtend(BUTTON_ANIMATION_DURATION)&#10;        }&#10;        binding.soundButton.setOnClickListener {&#10;            // mute/unmute voice instructions&#10;            isVoiceInstructionsMuted = !isVoiceInstructionsMuted&#10;        }&#10;&#10;        // set initial sounds button state&#10;        binding.soundButton.unmute()&#10;&#10;        routeInfoContainer.addView(infoView)&#10;&#10;        // Obtenha o destinoAdapter do HomeFragment&#10;        val homeFragment = requireParentFragment() as? HomeFragment&#10;        destinoAdapter = homeFragment?.getDestinoAdapter() ?: throw IllegalStateException(&quot;DestinoAdapter não encontrado&quot;)&#10;&#10;        // Verifique se está vazio ao criar a view&#10;        if (destinoAdapter.getDestinos().isEmpty()) {&#10;            // Encerra o fragmento imediatamente&#10;            encerrarFragmento()&#10;            return binding.root&#10;        }&#10;&#10;        // Registre o observer APÓS tudo estar pronto&#10;        // Remova qualquer registro duplicado em outros lugares&#10;        mapaFragment.setRouteProgressObserver(routeProgressObserver)&#10;&#10;        mapaFragment.setVoiceInstructionsObserver(voiceInstructionsObserver)&#10;&#10;        // initialize location puck&#10;        mapaFragment.mapView.location.apply {&#10;            setLocationProvider(mapaFragment.navigationLocationProvider)&#10;            this.locationPuck = LocationPuck2D(&#10;                bearingImage = ImageHolder.Companion.from(&#10;                    R.drawable.mapbox_navigation_puck_icon&#10;                )&#10;            )&#10;            puckBearingEnabled = true&#10;            enabled = true&#10;        }&#10;&#10;        // show UI elements&#10;        binding.soundButton.visibility = View.VISIBLE&#10;        binding.routeOverview.visibility = View.VISIBLE&#10;        //binding.tripProgressCard.visibility = View.VISIBLE&#10;        mapaFragment.cameraSeguir()&#10;        // Chame o método para obter DirectionsRoute e simular&#10;        rota?.let { rotaObj -&gt;&#10;            val accessToken = getString(R.string.mapbox_access_token)&#10;            solicitarDirectionsRouteViaMapMatching(rotaObj, accessToken) { directionsRoute -&gt;&#10;                directionsRoute?.let {&#10;                    mapaFragment.startSimulation(it)&#10;                }&#10;            }&#10;        }&#10;&#10;        if (mapaFragment.limitInfo != null) {&#10;            binding.speedLimitView.isVisible = true&#10;            binding.speedLimitView.render(mapaFragment.limitInfo!!)&#10;        } else {&#10;            binding.speedLimitView.isVisible = false&#10;        }&#10;&#10;        mapaFragment.navigationCamera.requestNavigationCameraToFollowing()&#10;&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        // Observe mudanças na lista de destinos e encerre se ficar vazio&#10;        destinoAdapter.registerAdapterDataObserver(object : RecyclerView.AdapterDataObserver() {&#10;            override fun onChanged() {&#10;                if (destinoAdapter.getDestinos().isEmpty()) {&#10;                    encerrarFragmento()&#10;                }&#10;            }&#10;            override fun onItemRangeRemoved(positionStart: Int, itemCount: Int) {&#10;                if (destinoAdapter.getDestinos().isEmpty()) {&#10;                    encerrarFragmento()&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    /**&#10;     * Solicita uma DirectionsRoute válida usando o Map Matching API.&#10;     */&#10;    private fun solicitarDirectionsRouteViaMapMatching(rota: Rota, accessToken: String, onResult: (DirectionsRoute?) -&gt; Unit) {&#10;        val pontos = listOf(rota.origemRota) + rota.destinosRota.map { it.localDestino }&#10;&#10;        val mapMatchingRequest = MapboxMapMatching.builder()&#10;            .accessToken(accessToken)&#10;            .coordinates(pontos)&#10;            .steps(true)&#10;            .voiceInstructions(true)&#10;            .bannerInstructions(true)&#10;            .profile(DirectionsCriteria.PROFILE_DRIVING)&#10;            .build()&#10;&#10;        mapMatchingRequest.enqueueCall(object : Callback&lt;MapMatchingResponse&gt; {&#10;            override fun onResponse(call: Call&lt;MapMatchingResponse&gt;, response: Response&lt;MapMatchingResponse&gt;) {&#10;                if (response.isSuccessful) {&#10;                    val directionsRoute = response.body()?.matchings()?.firstOrNull()?.toDirectionRoute()&#10;                    onResult(directionsRoute)&#10;                } else {&#10;                    onResult(null)&#10;                }&#10;            }&#10;            override fun onFailure(call: Call&lt;MapMatchingResponse&gt;, throwable: Throwable) {&#10;                onResult(null)&#10;            }&#10;        })&#10;    }&#10;&#10;    private fun clearRouteAndStopNavigation() {&#10;        // clear&#10;        //mapaFragment.mapboxNavigation.setNavigationRoutes(listOf())&#10;&#10;        // Limpa as setas&#10;        mapaFragment.routeArrowApi.clearArrows()&#10;&#10;        // stop simulation&#10;        mapaFragment.stopSimulation()&#10;&#10;        // hide UI elements&#10;        binding.soundButton.visibility = View.INVISIBLE&#10;        binding.maneuverView.visibility = View.INVISIBLE&#10;        binding.routeOverview.visibility = View.INVISIBLE&#10;        tripProgressCard.visibility = View.GONE&#10;    }&#10;&#10;    private fun encerrarFragmento(){&#10;        // Limpa rota e para navegação&#10;        clearRouteAndStopNavigation()&#10;&#10;        // Reverta o navigation puck para o estado original&#10;        mapaFragment.mapView.location.apply {&#10;            setLocationProvider(mapaFragment.navigationLocationProvider)&#10;            this.locationPuck = createDefault2DPuck()&#10;            puckBearingEnabled = true&#10;            enabled = true&#10;        }&#10;&#10;        // Remove todas as views do route_info_container para evitar duplicidade&#10;        val routeInfoContainer = requireActivity().findViewById&lt;ViewGroup&gt;(R.id.route_info_container)&#10;        routeInfoContainer.removeAllViews()&#10;&#10;        // Mostra novamente os componentes da HomeFragment&#10;        val homeFragment = requireParentFragment() as? HomeFragment&#10;        homeFragment?.let {&#10;            it.mostrarComponentes()&#10;            it.adicionarOnMapClickListenerParaPesquisa()&#10;            NavigationViewUtils.mostrarBottomNavigationView(requireActivity())&#10;        }&#10;&#10;        // Remove RouteFragment&#10;        parentFragmentManager.beginTransaction()&#10;            .remove(this)&#10;            .commit()&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        // Remova o observer apenas aqui&#10;        mapaFragment.removeRouteProgressObserver(routeProgressObserver)&#10;        mapaFragment.removeVoiceInstructionsObserver(voiceInstructionsObserver)&#10;        maneuverApi.cancel()&#10;        speechApi.cancel()&#10;        voiceInstructionsPlayer.shutdown()&#10;        _binding = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>